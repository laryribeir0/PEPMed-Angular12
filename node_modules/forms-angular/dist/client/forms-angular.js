/// <reference path="../../../../node_modules/@types/angular/index.d.ts" />
var fng;
(function (fng) {
    var directives;
    (function (directives) {
        /*@ngInject*/
        function modelControllerDropdown() {
            return {
                restrict: 'AE',
                replace: true,
                template: '<li ng-show="items.length > 0" class="mcdd" uib-dropdown>' +
                    ' <a href="#" uib-dropdown-toggle>' +
                    '  {{contextMenu}} <b class="caret"></b>' +
                    ' </a>' +
                    ' <ul class="uib-dropdown-menu dropdown-menu">' +
                    '  <li ng-repeat="choice in items" ng-hide="isHidden($index)" ng-class="dropdownClass($index)">' +
                    '   <a ng-show="choice.text || choice.textFunc" class="dropdown-option" ng-href="{{choice.url || choice.urlFunc()}}" ng-click="doClick($index, $event)">' +
                    '    {{ choice.text || choice.textFunc() }}' +
                    '   </a>' +
                    '  </li>' +
                    ' </ul>' +
                    '</li>'
            };
        }
        directives.modelControllerDropdown = modelControllerDropdown;
    })(directives = fng.directives || (fng.directives = {}));
})(fng || (fng = {}));
/// <reference path="../../../../node_modules/@types/angular/index.d.ts" />
var fng;
(function (fng) {
    var directives;
    (function (directives) {
        /*@ngInject*/
        errorDisplay.$inject = ["cssFrameworkService"];
        function errorDisplay(cssFrameworkService) {
            return {
                restrict: 'E',
                templateUrl: 'error-display-' + cssFrameworkService.framework() + '.html'
            };
        }
        directives.errorDisplay = errorDisplay;
    })(directives = fng.directives || (fng.directives = {}));
})(fng || (fng = {}));
/// <reference path="../../../../node_modules/@types/angular/index.d.ts" />
var fng;
(function (fng) {
    var controllers;
    (function (controllers) {
        /*@ngInject*/
        LinkCtrl.$inject = ["$scope"];
        function LinkCtrl($scope) {
            /**
             * In the event that the link is part of a form that belongs to a (ui-bootstrap) modal,
             * close the modal
             */
            $scope.checkNotModal = function () {
                var elm = $scope.element[0];
                var parentNode;
                var finished = false;
                var fakeEvt = {
                    preventDefault: angular.noop,
                    stopPropagation: angular.noop,
                    target: 1,
                    currentTarget: 1
                };
                do {
                    parentNode = elm.parentNode;
                    if (!parentNode) {
                        finished = true;
                    }
                    else if (typeof parentNode.getAttribute === "function" && parentNode.getAttribute('uib-modal-window')) {
                        angular.element(elm).scope().close(fakeEvt);
                        finished = true;
                    }
                    else {
                        elm = parentNode;
                    }
                } while (!finished);
            };
        }
        controllers.LinkCtrl = LinkCtrl;
    })(controllers = fng.controllers || (fng.controllers = {}));
})(fng || (fng = {}));
(function (fng) {
    var directives;
    (function (directives) {
        /*@ngInject*/
        fngLink.$inject = ["routingService", "SubmissionsService"];
        function fngLink(routingService, SubmissionsService) {
            return {
                restrict: 'E',
                scope: { dataSrc: '&model' },
                link: function (scope, element, attrs) {
                    var ref = attrs['ref'];
                    var isLabel = attrs['text'] && (unescape(attrs['text']) !== attrs['text']);
                    var form = attrs['form'];
                    var linktab = attrs['linktab'];
                    scope['readonly'] = attrs['readonly'];
                    scope['element'] = element;
                    form = form ? form + '/' : '';
                    linktab = linktab ? '/' + linktab : '';
                    if (isLabel) {
                        var workScope = scope;
                        var workString = '';
                        while (typeof workScope['baseSchema'] !== "function" && workScope.$parent) {
                            if (typeof workScope['$index'] !== "undefined") {
                                throw new Error('No support for $index at this level - ' + workString);
                            }
                            workScope = workScope.$parent;
                            workString = workString + '$parent.';
                        }
                        var attrib = attrs['fld'];
                        var watchExpression;
                        var splitAttrib = attrib.split('.');
                        if (scope.$parent.subDoc && (scope.$parent.subDoc[attrib] || scope.$parent.subDoc[splitAttrib[splitAttrib.length - 1]])) {
                            // Support for use in directives in arrays
                            if (scope.$parent.subDoc[attrib]) {
                                watchExpression = workString + 'subDoc.' + attrib;
                            }
                            else {
                                watchExpression = workString + 'subDoc.' + splitAttrib[splitAttrib.length - 1];
                            }
                        }
                        else {
                            if (typeof workScope['$index'] !== "undefined") {
                                attrib = splitAttrib.pop();
                                attrib = splitAttrib.join('.') + '[' + workScope['$index'] + '].' + attrib;
                            }
                            else {
                                attrib = '.' + attrib;
                            }
                            watchExpression = workString + 'record' + attrib;
                        }
                        scope.$watch(watchExpression, function (newVal) {
                            if (newVal) {
                                if (/^[a-f0-9]{24}/.test(newVal.toString())) {
                                    newVal = newVal.slice(0, 24);
                                }
                                else if (newVal.id && /^[a-f0-9]{24}/.test(newVal.id)) {
                                    newVal = newVal.id.slice(0, 24);
                                }
                                else if (scope.$parent["f_" + attrs['fld'] + "Options"]) {
                                    // extract from lookups
                                    var i = scope.$parent["f_" + attrs['fld'] + "Options"].indexOf(newVal);
                                    if (i > -1) {
                                        newVal = scope.$parent["f_" + attrs['fld'] + "_ids"][i];
                                    }
                                    else {
                                        newVal = undefined;
                                    }
                                }
                                else {
                                    newVal = undefined;
                                }
                                if (newVal) {
                                    scope['link'] = routingService.buildUrl(ref + '/' + form + (newVal.id || newVal) + '/edit' + linktab);
                                }
                                else {
                                    scope['link'] = undefined;
                                }
                            }
                            else {
                                scope['link'] = undefined;
                            }
                        }, true);
                    }
                    else {
                        if (attrs['text'] && attrs['text'].length > 0) {
                            scope['text'] = attrs['text'];
                        }
                        var index = scope['$parent']['$index'];
                        scope.$watch('dataSrc()', function (newVal) {
                            if (newVal) {
                                if (typeof index !== 'undefined' && angular.isArray(newVal)) {
                                    newVal = newVal[index];
                                }
                                scope['link'] = routingService.buildUrl(ref + '/' + form + newVal + '/edit' + linktab);
                                if (!scope['text']) {
                                    SubmissionsService.getListAttributes(ref, newVal).then(function (response) {
                                        var data = response.data;
                                        if (data.success === false) {
                                            scope['text'] = data.err;
                                        }
                                        else {
                                            scope['text'] = data.list;
                                        }
                                    }, function (response) {
                                        scope['text'] = 'Error ' + response.status + ': ' + response.data;
                                    });
                                }
                            }
                        }, true);
                    }
                },
                controller: "LinkCtrl",
                template: function (element, attrs) {
                    function handleAnchor(contents) {
                        return "<a ng-click=\"checkNotModal()\" ng-href=\"{{ link || '#' }}\" class=\"fng-link\">".concat(contents, "</a>");
                    }
                    var retVal;
                    if (attrs.readonly) {
                        retVal = '<span class="fng-link">{{text}}</span>';
                    }
                    else if (attrs['text'] && unescape(attrs['text']) !== attrs['text']) {
                        retVal = handleAnchor(unescape(attrs['text']));
                        // retVal = '<a href="{{ link }}" class="fng-link">{{text}}</a>';
                    }
                    else {
                        retVal = handleAnchor('{{text}}');
                    }
                    return retVal;
                }
            };
        }
        directives.fngLink = fngLink;
    })(directives = fng.directives || (fng.directives = {}));
})(fng || (fng = {}));
/// <reference path="../../../../node_modules/@types/angular/index.d.ts" />
var fng;
(function (fng) {
    var directives;
    (function (directives) {
        /*@ngInject*/
        formButtons.$inject = ["cssFrameworkService"];
        function formButtons(cssFrameworkService) {
            return {
                restrict: 'A',
                templateUrl: 'form-button-' + cssFrameworkService.framework() + '.html'
            };
        }
        directives.formButtons = formButtons;
    })(directives = fng.directives || (fng.directives = {}));
})(fng || (fng = {}));
/// <reference path="../../index.d.ts" />
var fng;
(function (fng) {
    var directives;
    (function (directives) {
        formInput.$inject = ["$compile", "$rootScope", "$filter", "$timeout", "cssFrameworkService", "formGenerator", "formMarkupHelper"];
        var tabsSetupState;
        (function (tabsSetupState) {
            tabsSetupState[tabsSetupState["Y"] = 0] = "Y";
            tabsSetupState[tabsSetupState["N"] = 1] = "N";
            tabsSetupState[tabsSetupState["Forced"] = 2] = "Forced";
        })(tabsSetupState || (tabsSetupState = {}));
        /*@ngInject*/
        function formInput($compile, $rootScope, $filter, $timeout, cssFrameworkService, formGenerator, formMarkupHelper) {
            return {
                restrict: 'EA',
                link: function (scope, element, attrs) {
                    //                generate markup for bootstrap forms
                    //
                    //                Bootstrap 3
                    //                Horizontal (default)
                    //                <div class="form-group">
                    //                    <label for="inputEmail3" class="col-sm-2 control-label">Email</label>
                    //                    <div class="col-sm-10">
                    //                        <input type="email" class="form-control" id="inputEmail3" placeholder="Email">
                    //                    </div>
                    //                 </div>
                    //
                    //                Vertical
                    //                <div class="form-group">
                    //                    <label for="exampleInputEmail1">Email address</label>
                    //                    <input type="email" class="form-control" id="exampleInputEmail1" placeholder="Enter email">
                    //                </div>
                    //
                    //                Inline or stacked
                    //                <div class="form-group">
                    //                    <label class="sr-only" for="exampleInputEmail2">Email address</label>
                    //                    <input type="email" class="form-control" id="exampleInputEmail2" placeholder="Enter email">
                    //                </div>
                    //                Bootstrap 2
                    //                Horizontal (default)
                    //                <div class="control-group">
                    //                    <label class="control-label" for="inputEmail">Email</label>
                    //                    <div class="controls">
                    //                        <input type="text" id="inputEmail" placeholder="Email">
                    //                    </div>
                    //                </div>
                    //
                    //                Vertical
                    //                <label>Label name</label>
                    //                <input type="text" placeholder="Type something…">
                    //                <span class="help-block">Example block-level help text here.</span>
                    //
                    //                Inline or Stacked
                    //                <input type="text" class="input-small" placeholder="Email">
                    var subkeys = [];
                    var tabsSetup = tabsSetupState.N;
                    var generateInput = function (fieldInfo, modelString, isRequired, idString, options) {
                        function generateEnumInstructions() {
                            var enumInstruction;
                            if (angular.isArray(scope[fieldInfo.options])) {
                                enumInstruction = { repeat: fieldInfo.options, value: 'option' };
                            }
                            else if (scope[fieldInfo.options] && angular.isArray(scope[fieldInfo.options].values)) {
                                if (angular.isArray(scope[fieldInfo.options].labels)) {
                                    enumInstruction = {
                                        repeat: fieldInfo.options + '.values',
                                        value: fieldInfo.options + '.values[$index]',
                                        label: fieldInfo.options + '.labels[$index]'
                                    };
                                }
                                else {
                                    enumInstruction = {
                                        repeat: fieldInfo.options + '.values',
                                        value: fieldInfo.options + '.values[$index]'
                                    };
                                }
                            }
                            else {
                                throw new Error('Invalid enumeration setup in field ' + fieldInfo.name);
                            }
                            return enumInstruction;
                        }
                        var nameString;
                        if (!modelString) {
                            var modelBase = (options.model || 'record') + '.';
                            modelString = modelBase;
                            if (options.subschema && fieldInfo.name.indexOf('.') !== -1) {
                                // Schema handling - need to massage the ngModel and the id
                                var compoundName = fieldInfo.name;
                                var root = options.subschemaroot;
                                var lastPart = compoundName.slice(root.length + 1);
                                if (options.index) {
                                    modelString += root + '[' + options.index + '].' + lastPart;
                                    idString = 'f_' + modelString.slice(modelBase.length).replace(/(\.|\[|]\.)/g, '-');
                                }
                                else {
                                    modelString += root;
                                    if (options.subkey) {
                                        idString = modelString.slice(modelBase.length).replace(/\./g, '-') + '-subkey' + options.subkeyno + '-' + lastPart;
                                        modelString += '[' + '$_arrayOffset_' + root.replace(/\./g, '_') + '_' + options.subkeyno + '].' + lastPart;
                                    }
                                    else {
                                        modelString += '[$index].' + lastPart;
                                        idString = null;
                                        nameString = compoundName.replace(/\./g, '-');
                                    }
                                }
                            }
                            else {
                                modelString += fieldInfo.name;
                            }
                        }
                        var allInputsVars = formMarkupHelper.allInputsVars(scope, fieldInfo, options, modelString, idString, nameString);
                        var common = allInputsVars.common;
                        var value;
                        isRequired = isRequired || fieldInfo.required;
                        var requiredStr = isRequired ? ' required ' : '';
                        var enumInstruction;
                        function handleReadOnlyDisabled(readonly) {
                            var retVal = '';
                            if (readonly) {
                                // despite the option being "readonly", we should use disabled and ng-disabled rather than their readonly
                                // equivalents (which give controls the appearance of being read-only, but don't actually prevent user
                                // interaction)
                                if (typeof readonly === "boolean") {
                                    retVal = " disabled ";
                                }
                                else {
                                    retVal = " ng-disabled=\"".concat(readonly, "\" ");
                                }
                            }
                            return retVal;
                        }
                        switch (fieldInfo.type) {
                            case 'select':
                                if (fieldInfo.select2) {
                                    value = '<input placeholder="fng-select2 has been removed" readonly>';
                                }
                                else {
                                    common += handleReadOnlyDisabled(fieldInfo.readonly);
                                    common += fieldInfo.add ? (' ' + fieldInfo.add + ' ') : '';
                                    common += " aria-label=\"".concat(fieldInfo.label && fieldInfo.label !== "" ? fieldInfo.label : fieldInfo.name, "\" ");
                                    value = '<select ' + common + 'class="' + allInputsVars.formControl.trim() + allInputsVars.compactClass + allInputsVars.sizeClassBS2 + '" ' + requiredStr + '>';
                                    if (!isRequired) {
                                        value += '<option></option>';
                                    }
                                    if (angular.isArray(fieldInfo.options)) {
                                        angular.forEach(fieldInfo.options, function (optValue) {
                                            if (_.isObject(optValue)) {
                                                value += '<option value="' + (optValue.val || optValue.id) + '">' + (optValue.label || optValue.text) + '</option>';
                                            }
                                            else {
                                                value += '<option>' + optValue + '</option>';
                                            }
                                        });
                                    }
                                    else {
                                        enumInstruction = generateEnumInstructions();
                                        value += '<option ng-repeat="option in ' + enumInstruction.repeat + '"';
                                        if (enumInstruction.label) {
                                            value += ' value="{{' + enumInstruction.value + '}}"> {{ ' + enumInstruction.label + ' }} </option> ';
                                        }
                                        else {
                                            value += '>{{' + enumInstruction.value + '}}</option> ';
                                        }
                                    }
                                    value += '</select>';
                                }
                                break;
                            case 'link':
                                value = '<fng-link model="' + modelString + '" ref="' + fieldInfo.ref + '"';
                                if (fieldInfo.form) {
                                    value += ' form="' + fieldInfo.form + '"';
                                }
                                if (fieldInfo.linktab) {
                                    value += ' linktab="' + fieldInfo.linktab + '"';
                                }
                                if (fieldInfo.linktext) {
                                    value += ' text="' + fieldInfo.linktext + '"';
                                }
                                if (fieldInfo.readonly) {
                                    if (typeof fieldInfo.readonly === "boolean") {
                                        value += " readonly=\"true\"";
                                    }
                                    else {
                                        value += " ng-readonly=\"".concat(fieldInfo.readonly, "\"");
                                    }
                                }
                                value += '></fng-link>';
                                break;
                            case 'radio':
                                value = '';
                                common += requiredStr;
                                common += handleReadOnlyDisabled(fieldInfo.readonly);
                                common += fieldInfo.add ? (' ' + fieldInfo.add + ' ') : '';
                                var separateLines = options.formstyle === 'vertical' || (options.formstyle !== 'inline' && !fieldInfo.inlineRadio);
                                if (angular.isArray(fieldInfo.options)) {
                                    if (options.subschema) {
                                        common = common.replace('name="', 'name="{{$index}}-');
                                        common = common.replace('id="', 'id="{{$index}}-');
                                    }
                                    var thisCommon_1;
                                    angular.forEach(fieldInfo.options, function (optValue, idx) {
                                        thisCommon_1 = common.replace('id="', 'id="' + idx + '-');
                                        value += "<input ".concat(thisCommon_1, " type=\"radio\" aria-label=\"").concat(optValue, "\" value=\"").concat(optValue, "\">").concat(optValue);
                                        if (separateLines) {
                                            value += '<br />';
                                        }
                                    });
                                }
                                else {
                                    var tagType = separateLines ? 'div' : 'span';
                                    if (options.subschema) {
                                        common = common.replace('$index', '$parent.$index')
                                            .replace('name="', 'name="{{$parent.$index}}-')
                                            .replace('id="', 'id="{{$parent.$index}}-');
                                    }
                                    enumInstruction = generateEnumInstructions();
                                    value += '<' + tagType + ' ng-repeat="option in ' + enumInstruction.repeat + '">';
                                    value += "<input ".concat(common.replace('id="', 'id="{{$index}}-'), " type=\"radio\" aria-label=\"").concat(enumInstruction.value, "\" value=\"{{ ").concat(enumInstruction.value, " }}\"> {{ ").concat(enumInstruction.label || enumInstruction.value, " }} </").concat(tagType, "> ");
                                }
                                break;
                            case 'checkbox':
                                common += requiredStr;
                                common += handleReadOnlyDisabled(fieldInfo.readonly);
                                common += fieldInfo.add ? (' ' + fieldInfo.add + ' ') : '';
                                value = formMarkupHelper.generateSimpleInput(common, fieldInfo, options);
                                if (cssFrameworkService.framework() === 'bs3') {
                                    value = '<div class="checkbox">' + value + '</div>';
                                }
                                break;
                            default:
                                common += formMarkupHelper.addTextInputMarkup(allInputsVars, fieldInfo, requiredStr);
                                if (fieldInfo.type === 'textarea') {
                                    if (fieldInfo.rows) {
                                        if (fieldInfo.rows === 'auto') {
                                            common += 'msd-elastic="\n" class="ng-animate" ';
                                        }
                                        else {
                                            common += 'rows = "' + fieldInfo.rows + '" ';
                                        }
                                    }
                                    if (fieldInfo.editor === 'ckEditor') {
                                        console.log('Deprecation Warning: "editor" property deprecated - use "add"');
                                        common += 'ckeditor = "" ';
                                        if (cssFrameworkService.framework() === 'bs3') {
                                            allInputsVars.sizeClassBS3 = 'col-xs-12';
                                        }
                                    }
                                    value = '<textarea ' + common + '></textarea>';
                                }
                                else {
                                    value = formMarkupHelper.generateSimpleInput(common, fieldInfo, options);
                                }
                        }
                        return formMarkupHelper.inputChrome(value, fieldInfo, options, allInputsVars);
                    };
                    var convertFormStyleToClass = function (aFormStyle) {
                        var result;
                        switch (aFormStyle) {
                            case 'horizontal':
                                result = 'form-horizontal';
                                break;
                            case 'vertical':
                                result = '';
                                break;
                            case 'inline':
                                result = 'form-inline';
                                break;
                            case 'stacked':
                                result = 'form-stacked';
                                break;
                            case 'horizontalCompact':
                                result = 'form-horizontal compact';
                                break;
                            default:
                                result = 'form-horizontal compact';
                                break;
                        }
                        return result;
                    };
                    var containerInstructions = function (info) {
                        var result = { before: '', after: '' };
                        if (typeof info.containerType === 'function') {
                            result = info.containerType(info);
                        }
                        else {
                            switch (info.containerType) {
                                case 'tab':
                                    var tabNo = -1;
                                    for (var i = 0; i < scope.tabs.length; i++) {
                                        if (scope.tabs[i].title === info.title) {
                                            tabNo = i;
                                            break;
                                        }
                                    }
                                    if (tabNo >= 0) {
                                        // TODO Figure out tab history updates (check for other tab-history-todos)
                                        // result.before = '<uib-tab deselect="tabDeselect($event, $selectedIndex)" select="updateQueryForTab(\'' + info.title + '\')" heading="' + info.title + '"'
                                        result.before = '<uib-tab deselect="tabDeselect($event, $selectedIndex)" select="updateQueryForTab(\'' + info.title + '\')" heading="' + info.title + '"';
                                        if (tabNo > 0) {
                                            result.before += 'active="tabs[' + tabNo + '].active"';
                                        }
                                        result.before += '>';
                                        result.after = '</uib-tab>';
                                    }
                                    else {
                                        result.before = '<p>Error!  Tab ' + info.title + ' not found in tab list</p>';
                                        result.after = '';
                                    }
                                    break;
                                case 'tabset':
                                    result.before = '<uib-tabset>';
                                    result.after = '</uib-tabset>';
                                    break;
                                case 'well':
                                    result.before = '<div class="well">';
                                    if (info.title) {
                                        result.before += '<h4>' + info.title + '</h4>';
                                    }
                                    result.after = '</div>';
                                    break;
                                case 'well-large':
                                    result.before = '<div class="well well-lg well-large">';
                                    result.after = '</div>';
                                    break;
                                case 'well-small':
                                    result.before = '<div class="well well-sm well-small">';
                                    result.after = '</div>';
                                    break;
                                case 'fieldset':
                                    result.before = '<fieldset>';
                                    if (info.title) {
                                        result.before += '<legend>' + info.title + '</legend>';
                                    }
                                    result.after = '</fieldset>';
                                    break;
                                case undefined:
                                    break;
                                case null:
                                    break;
                                case '':
                                    break;
                                default:
                                    result.before = '<div class="' + info.containerType + '">';
                                    if (info.title) {
                                        var titleLook = info.titleTagOrClass || 'h4';
                                        if (titleLook.match(/h[1-6]/)) {
                                            result.before += '<' + titleLook + '>' + info.title + '</' + titleLook + '>';
                                        }
                                        else {
                                            result.before += '<p class="' + titleLook + '">' + info.title + '</p>';
                                        }
                                    }
                                    result.after = '</div>';
                                    break;
                            }
                        }
                        return result;
                    };
                    var generateInlineHeaders = function (instructionsArray, options, model, evenWhenEmpty) {
                        // "column" headers for nested schemas that use formStyle: "inline" will only line up with their respective
                        // controls when widths are applied to both the cg_f_xxxx and col_label_xxxx element using css.
                        // Likely, the widths will need to be the same, so consider using the following:
                        //    div[id$="_f_<collection>_<field>"] {
                        //      width: 100px;
                        //    }
                        // one column can grow to the remaining available width thus:
                        //    div[id$="_f_<collection>_<field>"] {
                        //      flex-grow: 1;
                        //    }
                        var hideWhenEmpty = evenWhenEmpty ? "" : "ng-hide=\"!".concat(model, " || ").concat(model, ".length === 0\"");
                        var res = "<div class=\"inline-col-headers\" style=\"display:flex\" ".concat(hideWhenEmpty, ">");
                        for (var _i = 0, instructionsArray_1 = instructionsArray; _i < instructionsArray_1.length; _i++) {
                            var info = instructionsArray_1[_i];
                            // need to call this now to ensure the id is set. will probably be (harmlessly) called again later. 
                            inferMissingProperties(info, options);
                            res += '<div ';
                            info.showWhen = info.showWhen || info.showwhen; // deal with use within a directive
                            if (info.showWhen) {
                                if (typeof info.showWhen === 'string') {
                                    res += 'ng-show="' + info.showWhen + '"';
                                }
                                else {
                                    res += 'ng-show="' + formMarkupHelper.generateNgShow(info.showWhen, model) + '"';
                                }
                            }
                            if (info.id && typeof info.id.replace === "function") {
                                res += ' id="col_label_' + info.id.replace(/\./g, '-') + '"';
                            }
                            res += " class=\"inline-col-header\"><label for=\"".concat(info.id, "\" class=\"control-label\">").concat(info.label, "</label></div>");
                        }
                        res += "</div>";
                        return res;
                    };
                    var handleField = function (info, options) {
                        var fieldChrome = formMarkupHelper.fieldChrome(scope, info, options);
                        var template = fieldChrome.template;
                        if (info.schema) {
                            var niceName = info.name.replace(/\./g, '_');
                            var schemaDefName = '$_schema_' + niceName;
                            scope[schemaDefName] = info.schema;
                            if (info.schema) { // display as a control group
                                //schemas (which means they are arrays in Mongoose)
                                // Check for subkey - selecting out one or more of the array
                                if (info.subkey) {
                                    info.subkey.path = info.name;
                                    scope[schemaDefName + '_subkey'] = info.subkey;
                                    var subKeyArray = angular.isArray(info.subkey) ? info.subkey : [info.subkey];
                                    for (var arraySel = 0; arraySel < subKeyArray.length; arraySel++) {
                                        var topAndTail = containerInstructions(subKeyArray[arraySel]);
                                        template += topAndTail.before;
                                        template += processInstructions(info.schema, null, {
                                            subschema: 'true',
                                            formstyle: options.formstyle,
                                            subkey: schemaDefName + '_subkey',
                                            subkeyno: arraySel,
                                            subschemaroot: info.name,
                                            suppressNestingWarning: info.suppressNestingWarning
                                        });
                                        template += topAndTail.after;
                                    }
                                    subkeys.push(info);
                                }
                                else {
                                    if (options.subschema) {
                                        if (!options.suppressNestingWarning) {
                                            console.log('Attempts at supporting deep nesting have been removed - will hopefully be re-introduced at a later date');
                                        }
                                    }
                                    else {
                                        var model = (options.model || 'record') + '.' + info.name;
                                        /* Array header */
                                        if (typeof info.customHeader == 'string') {
                                            template += info.customHeader;
                                        }
                                        else {
                                            var topButton = '';
                                            if (info.unshift) {
                                                topButton = '<button id="unshift_' + info.id + '_btn" class="add-btn btn btn-default btn-xs btn-mini form-btn" ng-click="unshift(\'' + info.name + '\',$event)">' +
                                                    '<i class="' + formMarkupHelper.glyphClass() + '-plus"></i> Add</button>';
                                            }
                                            if (cssFrameworkService.framework() === 'bs3') {
                                                template += '<div class="row schema-head"><div class="col-sm-offset-3">' + info.label + topButton + '</div></div>';
                                            }
                                            else {
                                                template += '<div class="schema-head">' + info.label + topButton + '</div>';
                                            }
                                        }
                                        /* Array body */
                                        if (info.formStyle === "inline" && info.inlineHeaders) {
                                            template += generateInlineHeaders(info.schema, options, model, info.inlineHeaders === "always");
                                        }
                                        template += '<ol class="sub-doc"' + (info.sortable ? " ui-sortable=\"sortableOptions\" ng-model=\"".concat(model, "\"") : '') + '>';
                                        template += '<li ng-form class="' + (cssFrameworkService.framework() === 'bs2' ? 'row-fluid ' : '') +
                                            (info.inlineHeaders ? 'width-controlled ' : '') +
                                            convertFormStyleToClass(info.formStyle) + ' ' + (info.ngClass ? "ng-class:" + info.ngClass : "") + '" name="form_' + niceName + '{{$index}}" class="sub-doc well" id="' + info.id + 'List_{{$index}}" ' +
                                            ' ng-repeat="subDoc in ' + model + ' track by $index"' +
                                            (info.filterable ? ' data-ng-hide="subDoc._hidden"' : "") + '>';
                                        if (cssFrameworkService.framework() === 'bs2') {
                                            template += '<div class="row-fluid sub-doc">';
                                        }
                                        if (info.noRemove !== true || info.customSubDoc) {
                                            template += '   <div class="sub-doc-btns">';
                                            if (typeof info.customSubDoc == 'string') {
                                                template += info.customSubDoc;
                                            }
                                            if (info.noRemove !== true) {
                                                template += "<button ".concat(info.noRemove ? 'ng-hide="' + info.noRemove + '"' : '', " name=\"remove_").concat(info.id, "_btn\" ng-click=\"remove('").concat(info.name, "', $index, $event)\"");
                                                if (info.remove) {
                                                    template += ' class="remove-btn btn btn-mini btn-default btn-xs form-btn"><i class="' + formMarkupHelper.glyphClass() + '-minus"></i> Remove';
                                                }
                                                else {
                                                    template += ' style="position: relative; z-index: 20;" type="button" class="close pull-right">';
                                                    if (cssFrameworkService.framework() === 'bs3') {
                                                        template += '<span aria-hidden="true">×</span><span class="sr-only">Close</span>';
                                                    }
                                                    else {
                                                        template += '<span>×</span>';
                                                    }
                                                }
                                                template += '</button>';
                                            }
                                            template += '</div> ';
                                        }
                                        var parts = void 0;
                                        if (info.subDocContainerType) {
                                            var containerType = scope[info.subDocContainerType] || info.subDocContainerType;
                                            var containerProps = Object.assign({ containerType: containerType }, info.subDocContainerProps);
                                            parts = containerInstructions(containerProps);
                                        }
                                        if (parts === null || parts === void 0 ? void 0 : parts.before) {
                                            template += parts.before;
                                        }
                                        template += processInstructions(info.schema, false, {
                                            subschema: 'true',
                                            formstyle: info.formStyle,
                                            model: options.model,
                                            subschemaroot: info.name,
                                            suppressNestingWarning: info.suppressNestingWarning
                                        });
                                        if (parts === null || parts === void 0 ? void 0 : parts.after) {
                                            template += parts.after;
                                        }
                                        if (cssFrameworkService.framework() === 'bs2') {
                                            template += '   </div>';
                                        }
                                        template += '</li>';
                                        template += '</ol>';
                                        /* Array footer */
                                        if (info.noAdd !== true || typeof info.customFooter == 'string' || info.noneIndicator) {
                                            var footer = '';
                                            if (typeof info.customFooter == 'string') {
                                                footer = info.customFooter;
                                            }
                                            var hideCond = '';
                                            var indicatorShowCond = "".concat(model, ".length == 0");
                                            if (info.noAdd === true) {
                                                indicatorShowCond = "ng-show=\"".concat(indicatorShowCond, "\"");
                                            }
                                            else {
                                                hideCond = info.noAdd ? "ng-hide=\"".concat(info.noAdd, "\"") : '';
                                                indicatorShowCond = info.noAdd ? "ng-show=\"".concat(info.noAdd, " && ").concat(indicatorShowCond, "\"") : '';
                                                footer += "<button ".concat(hideCond, " id=\"add_").concat(info.id, "_btn\" class=\"add-btn btn btn-default btn-xs btn-mini\" ng-click=\"add('").concat(info.name, "',$event)\">\n                                   <i class=\"' + formMarkupHelper.glyphClass() + '-plus\"></i> \n                                   Add\n                                 </button>");
                                            }
                                            if (info.noneIndicator) {
                                                footer += "<span ".concat(indicatorShowCond, " class=\"none_indicator\" id=\"no_").concat(info.id, "_indicator\">None</span>");
                                                // hideCond for the schema-foot is if there's no add button and no indicator
                                                hideCond = "".concat(model, ".length > 0");
                                                if (info.noAdd === true) {
                                                    hideCond = "ng-hide=\"".concat(hideCond, "\"");
                                                }
                                                else {
                                                    hideCond = info.noAdd ? "ng-hide=\"".concat(info.noAdd, " && ").concat(hideCond, "\"") : '';
                                                }
                                            }
                                            if (footer !== '') {
                                                if (cssFrameworkService.framework() === 'bs3') {
                                                    template += "<div ".concat(hideCond, " class=\"row schema-foot\"><div class=\"col-sm-offset-3\">").concat(footer, "</div></div>");
                                                }
                                                else {
                                                    template += "<div ".concat(hideCond, " class = \"schema-foot \">").concat(footer, "</div>");
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        else {
                            // Handle arrays here
                            var controlDivClasses = formMarkupHelper.controlDivClasses(options);
                            if (info.array) {
                                controlDivClasses.push('fng-array');
                                if (options.formstyle === 'inline' || options.formstyle === 'stacked') {
                                    throw new Error('Cannot use arrays in an inline or stacked form');
                                }
                                template += formMarkupHelper.label(scope, info, info.type !== 'link', options);
                                template += formMarkupHelper.handleArrayInputAndControlDiv(generateInput(info, info.type === 'link' ? null : 'arrayItem.x', true, info.id + '_{{$index}}', options), controlDivClasses, info, options);
                            }
                            else {
                                // Single fields here
                                template += formMarkupHelper.label(scope, info, null, options);
                                template += formMarkupHelper.handleInputAndControlDiv(generateInput(info, null, options.required, info.id, options), controlDivClasses);
                            }
                        }
                        template += fieldChrome.closeTag;
                        return template;
                    };
                    var inferMissingProperties = function (info, options) {
                        // infer missing values
                        info.type = info.type || 'text';
                        if (info.id) {
                            if (typeof info.id === 'number' || info.id.match(/^[0-9]/)) {
                                info.id = '_' + info.id;
                            }
                        }
                        else {
                            if (options && options.noid) {
                                info.id = null;
                            }
                            else {
                                info.id = 'f_' + info.name.replace(/\./g, '_');
                            }
                        }
                        info.label = (info.label !== undefined) ? (info.label === null ? '' : info.label) : $filter('titleCase')(info.name.split('.').slice(-1)[0]);
                    };
                    //              var processInstructions = function (instructionsArray, topLevel, groupId) {
                    //  removing groupId as it was only used when called by containerType container, which is removed for now
                    var processInstructions = function (instructionsArray, topLevel, options) {
                        var result = '';
                        if (instructionsArray) {
                            for (var anInstruction = 0; anInstruction < instructionsArray.length; anInstruction++) {
                                var info = instructionsArray[anInstruction];
                                if (options.viewform) {
                                    info = angular.copy(info);
                                    info.readonly = true;
                                }
                                if (anInstruction === 0 && topLevel && !options.schema.match(/\$_schema_/) && typeof info.add !== 'object') {
                                    info.add = info.add ? ' ' + info.add + ' ' : '';
                                    if (info.add.indexOf('ui-date') === -1 && !options.noautofocus && !info.containerType) {
                                        info.add = info.add + 'autofocus ';
                                    }
                                }
                                var callHandleField = true;
                                if (info.directive) {
                                    var directiveName = info.directive;
                                    var newElement = info.customHeader || "";
                                    newElement += '<' + directiveName + ' model="' + (options.model || 'record') + '"';
                                    var thisElement = element[0];
                                    inferMissingProperties(info, options);
                                    for (var i = 0; i < thisElement.attributes.length; i++) {
                                        var thisAttr = thisElement.attributes[i];
                                        switch (thisAttr.nodeName) {
                                            case 'class':
                                                var classes = thisAttr.value.replace('ng-scope', '');
                                                if (classes.length > 0) {
                                                    newElement += ' class="' + classes + '"';
                                                }
                                                break;
                                            case 'schema':
                                                var bespokeSchemaDefName = ('bespoke_' + info.name).replace(/\./g, '_');
                                                scope[bespokeSchemaDefName] = angular.copy(info);
                                                delete scope[bespokeSchemaDefName].directive;
                                                newElement += ' schema="' + bespokeSchemaDefName + '"';
                                                break;
                                            default:
                                                newElement += ' ' + thisAttr.nodeName + '="' + thisAttr.value + '"';
                                        }
                                    }
                                    newElement += ' ';
                                    var directiveCamel = $filter('camelCase')(info.directive);
                                    for (var prop in info) {
                                        if (info.hasOwnProperty(prop)) {
                                            switch (prop) {
                                                case 'directive':
                                                    break;
                                                case 'schema':
                                                    break;
                                                case 'add':
                                                    switch (typeof info.add) {
                                                        case 'string':
                                                            newElement += ' ' + info.add;
                                                            break;
                                                        case 'object':
                                                            for (var subAdd in info.add) {
                                                                if (info.add.hasOwnProperty(subAdd)) {
                                                                    newElement += ' ' + subAdd + '="' + info.add[subAdd].toString().replace(/"/g, '&quot;') + '"';
                                                                }
                                                            }
                                                            break;
                                                        default:
                                                            throw new Error('Invalid add property of type ' + typeof (info.add) + ' in directive ' + info.name);
                                                    }
                                                    break;
                                                case directiveCamel:
                                                    for (var subProp in info[prop]) {
                                                        if (info[prop].hasOwnProperty(subProp)) {
                                                            newElement += " ".concat(info.directive, "-").concat(subProp, "=\"");
                                                            if (typeof info[prop][subProp] === 'string') {
                                                                newElement += "".concat(info[prop][subProp].replace(/"/g, '&quot;'), "\"");
                                                            }
                                                            else {
                                                                newElement += "".concat(JSON.stringify(info[prop][subProp]).replace(/"/g, '&quot;'), "\"");
                                                            }
                                                        }
                                                    }
                                                    break;
                                                default:
                                                    if (info[prop]) {
                                                        if (typeof info[prop] === 'string') {
                                                            newElement += ' fng-fld-' + prop + '="' + info[prop].replace(/"/g, '&quot;') + '"';
                                                        }
                                                        else {
                                                            newElement += ' fng-fld-' + prop + '="' + JSON.stringify(info[prop]).replace(/"/g, '&quot;') + '"';
                                                        }
                                                    }
                                                    break;
                                            }
                                        }
                                    }
                                    for (prop in options) {
                                        if (options.hasOwnProperty(prop) && prop[0] !== '$' && typeof options[prop] !== 'undefined') {
                                            newElement += ' fng-opt-' + prop + '="' + options[prop].toString().replace(/"/g, '&quot;') + '"';
                                        }
                                    }
                                    newElement += 'ng-model="' + info.name + '"></' + directiveName + '>';
                                    newElement += (info.customFooter || "");
                                    result += newElement;
                                    callHandleField = false;
                                }
                                else if (info.containerType) {
                                    var parts = containerInstructions(info);
                                    switch (info.containerType) {
                                        case 'tab':
                                            // maintain support for simplified tabset syntax for now
                                            if (tabsSetup === tabsSetupState.N) {
                                                tabsSetup = tabsSetupState.Forced;
                                                result += '<uib-tabset active="activeTabNo">';
                                                var activeTabNo = _.findIndex(scope.tabs, function (tab) { return (tab.active); });
                                                scope.activeTabNo = activeTabNo >= 0 ? activeTabNo : 0;
                                            }
                                            result += parts.before;
                                            result += processInstructions(info.content, null, options);
                                            result += parts.after;
                                            break;
                                        case 'tabset':
                                            tabsSetup = tabsSetupState.Y;
                                            result += parts.before;
                                            result += processInstructions(info.content, null, options);
                                            result += parts.after;
                                            break;
                                        default:
                                            // includes wells, fieldset
                                            result += parts.before;
                                            result += processInstructions(info.content, null, options);
                                            result += parts.after;
                                            break;
                                    }
                                    callHandleField = false;
                                }
                                else if (options.subkey) {
                                    // Don't display fields that form part of the subkey, as they should not be edited (because in these circumstances they form some kind of key)
                                    var objectToSearch = angular.isArray(scope[options.subkey]) ? scope[options.subkey][0].keyList : scope[options.subkey].keyList;
                                    if (_.find(objectToSearch, function (value, key) { return scope[options.subkey].path + '.' + key === info.name; })) {
                                        callHandleField = false;
                                    }
                                }
                                if (callHandleField) {
                                    //                            if (groupId) {
                                    //                                scope['showHide' + groupId] = true;
                                    //                            }
                                    inferMissingProperties(info, options);
                                    result += handleField(info, options);
                                }
                            }
                        }
                        else {
                            console.log('Empty array passed to processInstructions');
                            result = '';
                        }
                        return result;
                    };
                    var unwatch = scope.$watch(attrs.schema, function (newValue) {
                        if (newValue) {
                            var newArrayValue = angular.isArray(newValue) ? newValue : [newValue]; // otherwise some old tests stop working for no real reason
                            if (newArrayValue.length > 0 && typeof unwatch === "function") {
                                unwatch();
                                unwatch = null;
                                var elementHtml = '';
                                var recordAttribute = attrs.model || 'record'; // By default data comes from scope.record
                                var theRecord = scope[recordAttribute];
                                theRecord = theRecord || {};
                                if ((attrs.subschema || attrs.model) && !attrs.forceform) {
                                    elementHtml = '';
                                }
                                else {
                                    scope.topLevelFormName = attrs.name || 'myForm'; // Form name defaults to myForm
                                    // Copy attrs we don't process into form
                                    var customAttrs = '';
                                    for (var thisAttr in attrs) {
                                        if (attrs.hasOwnProperty(thisAttr)) {
                                            if (thisAttr[0] !== '$' && ['name', 'formstyle', 'schema', 'subschema', 'model', 'viewform'].indexOf(thisAttr) === -1) {
                                                customAttrs += ' ' + attrs.$attr[thisAttr] + '="' + attrs[thisAttr] + '"';
                                            }
                                        }
                                    }
                                    var tag = attrs.forceform ? 'ng-form' : 'form';
                                    elementHtml = "<".concat(tag, " name=\"").concat(scope.topLevelFormName, "\" class=\"").concat(convertFormStyleToClass(attrs.formstyle), "\" novalidate ").concat(customAttrs, ">");
                                }
                                if (theRecord === scope.topLevelFormName) {
                                    throw new Error('Model and Name must be distinct - they are both ' + theRecord);
                                }
                                elementHtml += processInstructions(newArrayValue, true, attrs);
                                if (tabsSetup === tabsSetupState.Forced) {
                                    elementHtml += '</uib-tabset>';
                                }
                                elementHtml += attrs.subschema ? '' : '</form>';
                                //console.log(elementHtml);
                                element.replaceWith($compile(elementHtml)(scope));
                                // If there are subkeys we need to fix up ng-model references when record is read
                                // If we have modelControllers we need to let them know when we have form + data
                                var sharedData = scope[attrs.shared || 'sharedData'];
                                var modelControllers_1 = sharedData ? sharedData.modelControllers : [];
                                if ((subkeys.length > 0 || modelControllers_1.length > 0) && !scope.phaseWatcher) {
                                    var unwatch2 = scope.$watch('phase', function (newValue) {
                                        scope.phaseWatcher = true;
                                        if (newValue === 'ready' && typeof unwatch2 === "function") {
                                            unwatch2();
                                            unwatch2 = null;
                                            // Tell the 'model controllers' that the form and data are there
                                            for (var i = 0; i < modelControllers_1.length; i++) {
                                                if (modelControllers_1[i].onAllReady) {
                                                    modelControllers_1[i].onAllReady(scope);
                                                }
                                            }
                                            // For each one of the subkeys sets in the form we need to fix up ng-model references
                                            for (var subkeyCtr = 0; subkeyCtr < subkeys.length; subkeyCtr++) {
                                                var info = subkeys[subkeyCtr];
                                                var arrayOffset;
                                                var matching;
                                                var arrayToProcess = angular.isArray(info.subkey) ? info.subkey : [info.subkey];
                                                var parts = info.name.split('.');
                                                var dataVal = theRecord;
                                                while (parts.length > 1) {
                                                    dataVal = dataVal[parts.shift()] || {};
                                                }
                                                dataVal = dataVal[parts[0]] = dataVal[parts[0]] || [];
                                                // For each of the required subkeys of this type
                                                for (var thisOffset = 0; thisOffset < arrayToProcess.length; thisOffset++) {
                                                    if (arrayToProcess[thisOffset].selectFunc) {
                                                        // Get the array offset from a function
                                                        if (!scope[arrayToProcess[thisOffset].selectFunc] || typeof scope[arrayToProcess[thisOffset].selectFunc] !== 'function') {
                                                            throw new Error('Subkey function ' + arrayToProcess[thisOffset].selectFunc + ' is not properly set up');
                                                        }
                                                        arrayOffset = scope[arrayToProcess[thisOffset].selectFunc](theRecord, info);
                                                    }
                                                    else if (arrayToProcess[thisOffset].keyList) {
                                                        // We are choosing the array element by matching one or more keys
                                                        var thisSubkeyList = arrayToProcess[thisOffset].keyList;
                                                        for (arrayOffset = 0; arrayOffset < dataVal.length; arrayOffset++) {
                                                            matching = true;
                                                            for (var keyField in thisSubkeyList) {
                                                                if (thisSubkeyList.hasOwnProperty(keyField)) {
                                                                    // Not (currently) concerned with objects here - just simple types and lookups
                                                                    if (dataVal[arrayOffset][keyField] !== thisSubkeyList[keyField] &&
                                                                        (typeof dataVal[arrayOffset][keyField] === 'undefined' || !dataVal[arrayOffset][keyField].text || dataVal[arrayOffset][keyField].text !== thisSubkeyList[keyField])) {
                                                                        matching = false;
                                                                        break;
                                                                    }
                                                                }
                                                            }
                                                            if (matching) {
                                                                break;
                                                            }
                                                        }
                                                        if (!matching) {
                                                            // There is no matching array element
                                                            switch (arrayToProcess[thisOffset].onNotFound) {
                                                                case 'error':
                                                                    var errorMessage = 'Cannot find matching ' + (arrayToProcess[thisOffset].title || arrayToProcess[thisOffset].path);
                                                                    //Have to do this async as setPristine clears it
                                                                    $timeout(function () {
                                                                        scope.showError(errorMessage, 'Unable to set up form correctly');
                                                                    });
                                                                    arrayOffset = -1;
                                                                    //throw new Error(scope.errorMessage);
                                                                    break;
                                                                case 'create':
                                                                default:
                                                                    var nameElements = info.name.split('.');
                                                                    var lastPart = nameElements.pop();
                                                                    var possibleArray = nameElements.join('.');
                                                                    var obj = theRecord;
                                                                    // Should loop here when / if we re-introduce nesting
                                                                    if (possibleArray) {
                                                                        obj = obj[possibleArray];
                                                                    }
                                                                    arrayOffset = obj[lastPart].push(thisSubkeyList) - 1;
                                                                    break;
                                                            }
                                                        }
                                                    }
                                                    else {
                                                        throw new Error('Invalid subkey setup for ' + info.name);
                                                    }
                                                    scope['$_arrayOffset_' + info.name.replace(/\./g, '_') + '_' + thisOffset] = arrayOffset;
                                                }
                                            }
                                        }
                                    });
                                }
                                $rootScope.$broadcast('formInputDone', attrs.name);
                                if (formGenerator.updateDataDependentDisplay && theRecord && Object.keys(theRecord).length > 0) {
                                    // If this is not a test force the data dependent updates to the DOM
                                    formGenerator.updateDataDependentDisplay(theRecord, null, true, scope);
                                }
                            }
                        }
                    }, true);
                }
            };
        }
        directives.formInput = formInput;
    })(directives = fng.directives || (fng.directives = {}));
})(fng || (fng = {}));
/// <reference path="../../../../node_modules/@types/angular/index.d.ts" />
var fng;
(function (fng) {
    var directives;
    (function (directives) {
        /*@ngInject*/
        function fngNakedDate() {
            return {
                restrict: 'A',
                require: 'ngModel',
                link: function postlink(scope, element, attrs, ngModel) {
                    ngModel.$parsers.push(function (value) {
                        if (value) {
                            return value.toString();
                        }
                    });
                    ngModel.$formatters.push(function (value) {
                        if (value) {
                            return new Date(value);
                        }
                    });
                }
            };
        }
        directives.fngNakedDate = fngNakedDate;
    })(directives = fng.directives || (fng.directives = {}));
})(fng || (fng = {}));
/// <reference path="../../../../node_modules/@types/angular/index.d.ts" />
var fng;
(function (fng) {
    var controllers;
    (function (controllers) {
        /*@ngInject*/
        SearchCtrl.$inject = ["$scope", "$http", "$location", "routingService"];
        function SearchCtrl($scope, $http, $location, routingService) {
            var lastSearchSent;
            var _isNotMobile;
            _isNotMobile = (function () {
                var check = false;
                (function (a) {
                    /* tslint:disable:max-line-length */
                    if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))) { // jshint ignore:line
                        /* tslint:enable:max-line-length */
                        check = true;
                    }
                })(navigator.userAgent || navigator.vendor || window['opera']);
                return !check;
            })();
            $scope.searchPlaceholder = _isNotMobile ? 'Ctrl + / to Search' : 'Search';
            $scope.handleKey = function (event) {
                if (event.keyCode === 27 && $scope.searchTarget && $scope.searchTarget.length > 0) {
                    $scope.searchTarget = '';
                }
                else if ($scope.results.length > 0) {
                    switch (event.keyCode) {
                        case 38:
                            // up arrow pressed
                            if ($scope.focus > 0) {
                                $scope.setFocus($scope.focus - 1);
                            }
                            if (typeof event.preventDefault === 'function') {
                                event.preventDefault();
                            }
                            break;
                        case 40:
                            // down arrow pressed
                            if ($scope.results.length > $scope.focus + 1) {
                                $scope.setFocus($scope.focus + 1);
                            }
                            if (typeof event.preventDefault === 'function') {
                                event.preventDefault();
                            }
                            break;
                        case 13:
                            if ($scope.focus != null) {
                                $location.url(makeUrlNoHtml5Hash($scope.results[$scope.focus]));
                            }
                            break;
                    }
                }
            };
            $scope.setFocus = function (index) {
                if ($scope.focus !== null) {
                    delete $scope.results[$scope.focus].focussed;
                }
                $scope.results[index].focussed = true;
                $scope.focus = index;
            };
            $scope.resultClass = function (index) {
                var resultClass = 'search-result';
                if ($scope.results && $scope.results[index].focussed) {
                    resultClass += ' focus';
                }
                return resultClass;
            };
            var clearSearchResults = function () {
                $scope.moreCount = 0;
                $scope.errorClass = '';
                $scope.results = [];
                $scope.focus = null;
            };
            function makeUrlNoHtml5Hash(result) {
                return result.url ? routingService.html5hash() + result.url.replace('|id|', result.id) :
                    routingService.buildOperationUrl('edit', result.resource, undefined, result.id, result.resourceTab);
            }
            $scope.$watch('searchTarget', function (newValue) {
                if (newValue && newValue.length > 0) {
                    lastSearchSent = $scope.testTime || new Date().valueOf();
                    $http.get('/api/search?q=' + newValue + '&sentAt=' + lastSearchSent).then(function (response) {
                        var data = response.data;
                        // Check that we haven't fired off a subsequent request, in which
                        // case we are no longer interested in these results
                        if (!data.timestamps || !data.timestamps.sentAt || Number.parseInt(data.timestamps.sentAt) === lastSearchSent) {
                            if ($scope.searchTarget.length > 0) {
                                $scope.results = data.results;
                                $scope.results.forEach(function (result) {
                                    result.href = routingService.html5hash() + makeUrlNoHtml5Hash(result);
                                });
                                $scope.moreCount = data.moreCount;
                                if (data.results.length > 0) {
                                    $scope.errorClass = '';
                                    $scope.setFocus(0);
                                }
                                $scope.errorClass = $scope.results.length === 0 ? 'error has-error' : '';
                            }
                            else {
                                clearSearchResults();
                            }
                        }
                    }, function (response) {
                        console.log('Error in searchbox.js : ' + response.data + ' (status=' + response.status + ')');
                    });
                }
                else {
                    clearSearchResults();
                }
            }, true);
            $scope.$on('$routeChangeStart', function () {
                $scope.searchTarget = '';
            });
        }
        controllers.SearchCtrl = SearchCtrl;
    })(controllers = fng.controllers || (fng.controllers = {}));
})(fng || (fng = {}));
/// <reference path="../../../../node_modules/@types/angular/index.d.ts" />
/// <reference path="../controllers/search-ctrl.ts" />
var fng;
(function (fng) {
    var directives;
    (function (directives) {
        /*@ngInject*/
        globalSearch.$inject = ["cssFrameworkService"];
        function globalSearch(cssFrameworkService) {
            return {
                restrict: 'AE',
                templateUrl: 'search-' + cssFrameworkService.framework() + '.html',
                controller: fng.controllers.SearchCtrl
            };
        }
        directives.globalSearch = globalSearch;
    })(directives = fng.directives || (fng.directives = {}));
})(fng || (fng = {}));
/// <reference path="../../../../node_modules/@types/angular/index.d.ts" />
var fng;
(function (fng) {
    var filters;
    (function (filters) {
        /*@ngInject*/
        function camelCase() {
            return function (name) {
                var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
                return name.
                    replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {
                    return offset ? letter.toUpperCase() : letter;
                });
            };
        }
        filters.camelCase = camelCase;
    })(filters = fng.filters || (fng.filters = {}));
})(fng || (fng = {}));
/// <reference path="../../../../node_modules/@types/angular/index.d.ts" />
var fng;
(function (fng) {
    var filters;
    (function (filters) {
        /*@ngInject*/
        function extractTimestampFromMongoID() {
            return function (id) {
                var timestamp = id.substring(0, 8);
                return new Date(parseInt(timestamp, 16) * 1000);
            };
        }
        filters.extractTimestampFromMongoID = extractTimestampFromMongoID;
    })(filters = fng.filters || (fng.filters = {}));
})(fng || (fng = {}));
/// <reference path="../../../../node_modules/@types/angular/index.d.ts" />
var fng;
(function (fng) {
    var filters;
    (function (filters) {
        /*@ngInject*/
        function titleCase() {
            return function (str, stripSpaces) {
                if (str) {
                    str = str
                        .replace(/(_|\.)/g, ' ') // replace underscores and dots with spaces
                        .replace(/[A-Z]/g, ' $&').trim() // precede replace caps with a space
                        .replace(/\w\S*/g, function (txt) {
                        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
                    });
                    if (stripSpaces) {
                        str = str.replace(/\s/g, '');
                    }
                    else {
                        // lose double spaces
                        str = str.replace(/\s{2,}/g, ' ');
                    }
                }
                return str;
            };
        }
        filters.titleCase = titleCase;
    })(filters = fng.filters || (fng.filters = {}));
})(fng || (fng = {}));
/// <reference path="../../../../node_modules/@types/angular/index.d.ts" />
var fng;
(function (fng) {
    var services;
    (function (services) {
        /*@ngInject*/
        function addAllService() {
            this.getAddAllGroupOptions = function (scope, attrs, classes) {
                return getAddAllOptions(scope, attrs, 'Group', classes);
            };
            this.getAddAllFieldOptions = function (scope, attrs, classes) {
                return getAddAllOptions(scope, attrs, 'Field', classes);
            };
            this.getAddAllLabelOptions = function (scope, attrs, classes) {
                return getAddAllOptions(scope, attrs, 'Label', classes);
            };
            this.addAll = function (scope, type, additionalClasses, options) {
                var action = 'getAddAll' + type + 'Options';
                return this[action](scope, options, additionalClasses) || [];
            };
            function getAddAllOptions(scope, attrs, type, classes) {
                var addAllOptions = [], classList = [], tmp, i, options;
                type = 'addAll' + type;
                if (typeof (classes) === 'string') {
                    tmp = classes.split(' ');
                    for (i = 0; i < tmp.length; i++) {
                        classList.push(tmp[i]);
                    }
                }
                function getAllOptions(obj) {
                    for (var key in obj) {
                        if (key === type) {
                            addAllOptions.push(obj[key]);
                        }
                        if (key === '$parent') {
                            getAllOptions(obj[key]);
                        }
                    }
                }
                getAllOptions(scope);
                if (attrs[type] !== undefined) {
                    // TODO add support for objects and raise error on invalid types
                    if (typeof (attrs[type]) === 'string') {
                        tmp = attrs[type].split(' ');
                        for (i = 0; i < tmp.length; i++) {
                            if (tmp[i].indexOf('class=') === 0) {
                                classList.push(tmp[i].substring(6, tmp[i].length));
                            }
                            else {
                                addAllOptions.push(tmp[i]);
                            }
                        }
                    }
                }
                if (classList.length > 0) {
                    classes = ' class="' + classList.join(' ') + '" ';
                }
                else {
                    classes = ' ';
                }
                if (addAllOptions.length > 0) {
                    options = addAllOptions.join(' ') + ' ';
                }
                else {
                    options = '';
                }
                return classes + options;
            }
        }
        services.addAllService = addAllService;
    })(services = fng.services || (fng.services = {}));
})(fng || (fng = {}));
/// <reference path="../../../../node_modules/@types/angular/index.d.ts" />
var fng;
(function (fng) {
    var services;
    (function (services) {
        /*@ngInject*/
        function cssFrameworkService() {
            // Bootstrap 3 is now the only supported framework
            // Bootstrap 2 can be made to work - an example can be made available if you request on gitter.
            var config = {
                framework: 'bs3'
            };
            return {
                setOptions: function (options) {
                    angular.extend(config, options);
                },
                $get: function () {
                    return {
                        framework: function () {
                            return config.framework;
                        },
                        // This next function is just for the demo website - don't use it
                        setFrameworkForDemoWebsite: function (framework) {
                            config.framework = framework;
                        },
                        span: function (cols) {
                            var result;
                            switch (config.framework) {
                                case 'bs2':
                                    result = 'span' + Math.floor(cols);
                                    break;
                                case 'bs3':
                                    result = 'col-xs-' + Math.floor(cols);
                                    break;
                            }
                            return result;
                        },
                        offset: function (cols) {
                            var result;
                            switch (config.framework) {
                                case 'bs2':
                                    result = 'offset' + Math.floor(cols);
                                    break;
                                case 'bs3':
                                    result = 'col-lg-offset-' + Math.floor(cols);
                                    break;
                            }
                            return result;
                        },
                        rowFluid: function () {
                            var result;
                            switch (config.framework) {
                                case 'bs2':
                                    result = 'row-fluid';
                                    break;
                                case 'bs3':
                                    result = 'row';
                                    break;
                            }
                            return result;
                        }
                    };
                }
            };
        }
        services.cssFrameworkService = cssFrameworkService;
    })(services = fng.services || (fng.services = {}));
})(fng || (fng = {}));
/// <reference path="../../index.d.ts" />
var fng;
(function (fng) {
    var services;
    (function (services) {
        /*@ngInject*/
        function fngModelCtrlService($controller) {
            return {
                loadControllerAndMenu: function (sharedData, controllerName, level, needDivider, localScope) {
                    var locals = {}, addThis;
                    controllerName += 'Ctrl';
                    locals.$scope = sharedData.modelControllers[level] = localScope;
                    var parentScope = localScope.$parent;
                    parentScope.items = parentScope.items || [];
                    var addMenuOptions = function (array) {
                        angular.forEach(array, function (value) {
                            if (value.divider) {
                                needDivider = true;
                            }
                            else if (value[addThis]) {
                                if (needDivider) {
                                    needDivider = false;
                                    parentScope.items.push({ divider: true });
                                }
                                parentScope.items.push(value);
                            }
                        });
                    };
                    try {
                        $controller(controllerName, locals);
                        if (parentScope.newRecord) {
                            addThis = 'creating';
                        }
                        else if (parentScope.id) {
                            addThis = 'editing';
                        }
                        else {
                            addThis = 'listing';
                        }
                        if (angular.isObject(locals.$scope.contextMenu)) {
                            addMenuOptions(locals.$scope.contextMenu);
                            if (locals.$scope.contextMenuPromise) {
                                locals.$scope.contextMenuPromise.then(function (array) { return addMenuOptions(array); });
                            }
                        }
                        if (sharedData.modelNameDisplayPromise) {
                            sharedData.modelNameDisplayPromise.then(function (value) {
                                parentScope.modelNameDisplay = value;
                            });
                        }
                    }
                    catch (error) {
                        // Check to see if error is no such controller - don't care
                        if ((!(/is not a function, got undefined/.test(error.message))) && (!(/\[\$controller:ctrlreg\] The controller with the name/.test(error.message)))) {
                            console.log('Unable to instantiate ' + controllerName + ' - ' + error.message);
                        }
                    }
                }
            };
        }
        services.fngModelCtrlService = fngModelCtrlService;
        fngModelCtrlService.$inject = ["$controller"];
    })(services = fng.services || (fng.services = {}));
})(fng || (fng = {}));
/// <reference path="../../index.d.ts" />
var fng;
(function (fng) {
    var services;
    (function (services) {
        /*@ngInject*/
        routingService.$inject = ["$injector", "$locationProvider"];
        function routingService($injector, $locationProvider) {
            var config = {
                //  fixedRoutes: [] an array in the same format as builtInRoutes that is matched before the generic routes.  Can be omitted
                hashPrefix: '',
                html5Mode: false,
                routing: 'ngroute',
                prefix: '' // How do we want to prefix our routes?  If not empty string then first character must be slash (which is added if not)
            };
            var postActions = ['edit', 'view'];
            var builtInRoutes = [
                {
                    route: '/analyse/:model/:reportSchemaName',
                    state: 'analyse::model::report',
                    templateUrl: 'base-analysis.html'
                },
                { route: '/analyse/:model', state: 'analyse::model', templateUrl: 'base-analysis.html' },
                { route: '/:model/:id/edit', state: 'model::edit', templateUrl: 'base-edit.html' },
                { route: '/:model/:id/edit/:tab', state: 'model::edit::tab', templateUrl: 'base-edit.html' },
                { route: '/:model/:id/view', state: 'model::edit', templateUrl: 'base-view.html' },
                { route: '/:model/:id/view/:tab', state: 'model::view::tab', templateUrl: 'base-view.html' },
                { route: '/:model/new', state: 'model::new', templateUrl: 'base-edit.html' },
                { route: '/:model', state: 'model::list', templateUrl: 'base-list.html' },
                { route: '/:model/viewonly', state: 'model::view', templateUrl: 'base-list-view.html' },
                // Non default form (subset of fields etc)
                { route: '/:model/:form/:id/edit', state: 'model::form::edit', templateUrl: 'base-edit.html' },
                { route: '/:model/:form/:id/edit/:tab', state: 'model::form::edit::tab', templateUrl: 'base-edit.html' },
                { route: '/:model/:form/:id/view', state: 'model::form::view', templateUrl: 'base-view.html' },
                { route: '/:model/:form/:id/view/:tab', state: 'model::form::view::tab', templateUrl: 'base-view.html' },
                { route: '/:model/:form/new', state: 'model::form::new', templateUrl: 'base-edit.html' },
                { route: '/:model/:form', state: 'model::form::list', templateUrl: 'base-list.html' },
                { route: '/:model/:form/viewonly', state: 'model::form::list::view', templateUrl: 'base-list-view.html' } // list page with edit links to non default form
            ];
            var _routeProvider, _stateProvider;
            var lastRoute = null;
            var lastObject = {};
            function handleFolder(templateURL) {
                var retVal = templateURL;
                if (config.templateFolder) {
                    if (config.templateFolder[config.templateFolder.length - 1] !== '/') {
                        retVal = config.templateFolder + '/' + retVal;
                    }
                    else {
                        retVal = config.templateFolder + retVal;
                    }
                }
                return retVal;
            }
            function _setUpNgRoutes(routes, prefix, additional) {
                if (prefix === void 0) { prefix = ''; }
                prefix = prefix || '';
                angular.forEach(routes, function (routeSpec) {
                    _routeProvider.when(prefix + routeSpec.route, angular.extend(routeSpec.options || { templateUrl: handleFolder(routeSpec.templateUrl) }, additional));
                });
                // This next bit is just for the demo website to allow demonstrating multiple CSS frameworks - not available with other routers
                if (config.variantsForDemoWebsite) {
                    angular.forEach(config.variantsForDemoWebsite, function (variant) {
                        angular.forEach(routes, function (routeSpec) {
                            _routeProvider.when(prefix + variant + routeSpec.route, angular.extend(routeSpec.options || { templateUrl: handleFolder(routeSpec.templateUrl) }, additional));
                        });
                    });
                }
            }
            function _setUpUIRoutes(routes, prefix, additional) {
                if (prefix === void 0) { prefix = ''; }
                prefix = prefix || '';
                angular.forEach(routes, function (routeSpec) {
                    _stateProvider.state(routeSpec.state, angular.extend(routeSpec.options || {
                        url: prefix + routeSpec.route,
                        templateUrl: routeSpec.templateUrl
                    }, additional));
                });
            }
            function _buildOperationUrl(prefix, operation, modelName, formName, id, tabName) {
                var formString = formName ? ('/' + formName) : '';
                var modelString = prefix + '/' + modelName;
                var tabString = tabName ? ('/' + tabName) : '';
                var urlStr;
                switch (operation) {
                    case 'list':
                        urlStr = modelString + formString;
                        break;
                    case 'edit':
                        urlStr = modelString + formString + '/' + id + '/edit' + tabString;
                        break;
                    case 'view':
                        urlStr = modelString + formString + '/' + id + '/view' + tabString;
                        break;
                    case 'read':
                        urlStr = modelString + formString + '/' + id + '/read' + tabString;
                        break;
                    case 'new':
                        urlStr = modelString + formString + '/new' + tabString;
                        break;
                }
                return urlStr;
            }
            function _setUpRoutes(fixedRoutes, fngRoutes) {
                switch (config.routing) {
                    case 'ngroute':
                        _routeProvider = $injector.get('$routeProvider');
                        if (fixedRoutes) {
                            _setUpNgRoutes(fixedRoutes);
                        }
                        _setUpNgRoutes(fngRoutes, config.prefix, config.add2fngRoutes);
                        break;
                    case 'uirouter':
                        _stateProvider = $injector.get('$stateProvider');
                        if (fixedRoutes) {
                            _setUpUIRoutes(config.fixedRoutes);
                        }
                        _setUpUIRoutes(fngRoutes, config.prefix, config.add2fngRoutes);
                        break;
                }
            }
            return {
                start: function (options) {
                    angular.extend(config, options);
                    if (config.prefix[0] && config.prefix[0] !== '/') {
                        config.prefix = '/' + config.prefix;
                    }
                    $locationProvider.html5Mode(config.html5Mode);
                    if (config.hashPrefix !== '') {
                        $locationProvider.hashPrefix(config.hashPrefix);
                    }
                    else if (!config.html5Mode) {
                        $locationProvider.hashPrefix('');
                    }
                    _setUpRoutes(config.fixedRoutes, builtInRoutes);
                },
                addRoutes: function (fixedRoutes, fngRoutes) {
                    _setUpRoutes(fixedRoutes, fngRoutes);
                },
                registerAction: function (action) {
                    postActions.push(action);
                },
                $get: function () {
                    return {
                        router: function () {
                            return config.routing;
                        },
                        prefix: function () {
                            return config.prefix;
                        },
                        parsePathFunc: function () {
                            return function (location) {
                                if (location !== lastRoute) {
                                    lastRoute = location;
                                    lastObject = { newRecord: false };
                                    // Get rid of the prefix
                                    if (config.prefix.length > 0) {
                                        if (location.indexOf(config.prefix) === 0) {
                                            location = location.slice(config.prefix.length);
                                        }
                                    }
                                    var locationSplit = location.split('/');
                                    // get rid of variant if present - just used for demo website
                                    if (config.variants) {
                                        if (config.variants.indexOf(locationSplit[1]) !== -1) {
                                            lastObject.variant = locationSplit[1];
                                            locationSplit.shift();
                                        }
                                    }
                                    var locationParts = locationSplit.length;
                                    if (locationSplit[1] === 'analyse') {
                                        lastObject.analyse = true;
                                        lastObject.modelName = locationSplit[2];
                                        lastObject.reportSchemaName = locationParts >= 4 ? locationSplit[3] : null;
                                    }
                                    else {
                                        lastObject.modelName = locationSplit[1];
                                        var lastParts_1 = [locationSplit[locationParts - 1], locationSplit[locationParts - 2]];
                                        var newPos = lastParts_1.indexOf('new');
                                        var viewonlyPos = lastParts_1.indexOf('viewonly');
                                        var actionPos = void 0;
                                        if (newPos === -1 && viewonlyPos === -1) {
                                            actionPos = postActions.reduce(function (previousValue, currentValue) {
                                                var pos = lastParts_1.indexOf(currentValue);
                                                return pos > -1 ? pos : previousValue;
                                            }, -1);
                                            if (actionPos !== -1) {
                                                locationParts -= (2 + actionPos);
                                                lastObject.id = locationSplit[locationParts];
                                            }
                                        }
                                        else if (newPos !== -1) {
                                            lastObject.newRecord = true;
                                            locationParts -= (1 + newPos);
                                        }
                                        else {
                                            locationParts -= (1 + viewonlyPos);
                                        }
                                        if (actionPos === 1 || newPos === 1) {
                                            lastObject.tab = lastParts_1[0];
                                        }
                                        if (locationParts > 2) {
                                            lastObject.formName = locationSplit[2];
                                        }
                                    }
                                }
                                return lastObject;
                            };
                        },
                        html5hash: function () {
                            return config.html5Mode ? '' : '#';
                        },
                        buildUrl: function (path) {
                            var url = config.html5Mode ? '' : '#';
                            url += config.hashPrefix;
                            url += config.prefix;
                            if (url[0]) {
                                url += '/';
                            }
                            url += (path[0] === '/' ? path.slice(1) : path);
                            return url;
                        },
                        buildOperationUrl: function (operation, modelName, formName, id, tab) {
                            return _buildOperationUrl(config.prefix, operation, modelName, formName, id, tab);
                        },
                        redirectTo: function () {
                            return function (operation, scope, location, id, tab) {
                                location.search({}); // Lose any search parameters
                                var urlStr;
                                if (operation === 'onDelete') {
                                    if (config.onDelete) {
                                        if (config.onDelete === 'new') {
                                            urlStr = _buildOperationUrl(config.prefix, 'new', scope.modelName, scope.formName, id, tab);
                                        }
                                        else {
                                            urlStr = config.onDelete;
                                        }
                                    }
                                    else {
                                        urlStr = _buildOperationUrl(config.prefix, 'list', scope.modelName, scope.formName, id, tab);
                                    }
                                }
                                else {
                                    urlStr = _buildOperationUrl(config.prefix, operation, scope.modelName, scope.formName, id, tab);
                                }
                                location.path(urlStr);
                            };
                        }
                    };
                }
            };
        }
        services.routingService = routingService;
    })(services = fng.services || (fng.services = {}));
})(fng || (fng = {}));
/// <reference path="../../index.d.ts" />
var fng;
(function (fng) {
    var services;
    (function (services) {
        /**
         *
         * Manipulate record items for generating a form
         *
         * All methods should be state-less
         *
         */
        function formGenerator($location, $timeout, $filter, routingService, recordHandler) {
            function handleSchema(description, source, destForm, destList, prefix, doRecursion, $scope, ctrlState) {
                function handletabInfo(tabName, thisInst) {
                    var tabTitle = angular.copy(tabName);
                    var tab = _.find($scope.tabs, function (atab) {
                        return atab.title === tabTitle;
                    });
                    if (!tab) {
                        if ($scope.tabs.length === 0) {
                            if ($scope.formSchema.length > 0) {
                                $scope.tabs.push({ title: 'Main', content: [], active: ($scope.tab === 'Main' || !$scope.tab) });
                                tab = $scope.tabs[0];
                                for (var i = 0; i < $scope.formSchema.length; i++) {
                                    tab.content.push($scope.formSchema[i]);
                                }
                            }
                        }
                        tab = $scope.tabs[$scope.tabs.push({
                            title: tabTitle,
                            containerType: 'tab',
                            content: [],
                            active: (tabTitle === $scope.tab)
                        }) - 1];
                    }
                    tab.content.push(thisInst);
                }
                if (typeof $scope.onSchemaFetch === "function") {
                    $scope.onSchemaFetch(description, source);
                }
                for (var field in source) {
                    if (source.hasOwnProperty(field)) {
                        if (field === '_id') {
                            if (destList && source['_id'].options && source['_id'].options.list) {
                                handleListInfo(destList, source['_id'].options.list, field);
                            }
                        }
                        else if (source.hasOwnProperty(field)) {
                            var mongooseType = source[field], mongooseOptions = mongooseType.options || {};
                            var formData = mongooseOptions.form || {};
                            if (mongooseType.schema && !formData.hidden) {
                                if (doRecursion && destForm) {
                                    var schemaSchema = [];
                                    handleSchema('Nested ' + field, mongooseType.schema, schemaSchema, null, field + '.', true, $scope, ctrlState);
                                    var sectionInstructions = basicInstructions(field, formData, prefix);
                                    sectionInstructions.schema = schemaSchema;
                                    if (formData.tab) {
                                        handletabInfo(formData.tab, sectionInstructions);
                                    }
                                    if (formData.order !== undefined) {
                                        destForm.splice(formData.order, 0, sectionInstructions);
                                    }
                                    else {
                                        destForm.push(sectionInstructions);
                                    }
                                }
                            }
                            else {
                                if (destForm && !formData.hidden) {
                                    var formInstructions = basicInstructions(field, formData, prefix);
                                    if (handleConditionals(formInstructions.showIf, formInstructions.name, $scope) && field !== 'options') {
                                        var formInst = handleFieldType(formInstructions, mongooseType, mongooseOptions, $scope, ctrlState);
                                        if (formInst.tab) {
                                            handletabInfo(formInst.tab, formInst);
                                        }
                                        if (formData.order !== undefined) {
                                            destForm.splice(formData.order, 0, formInst);
                                        }
                                        else {
                                            destForm.push(formInst);
                                        }
                                    }
                                }
                                if (destList && mongooseOptions.list) {
                                    handleListInfo(destList, mongooseOptions.list, field);
                                }
                            }
                        }
                    }
                }
                //        //if a hash is defined then make that the selected tab is displayed
                //        if ($scope.tabs.length > 0 && $location.hash()) {
                //            var tab = _.find($scope.tabs, function (atab) {
                //                return atab.title === $location.hash();
                //            });
                //
                //            if (tab) {
                //                for (var i = 0; i < $scope.tabs.length; i++) {
                //                    $scope.tabs[i].active = false;
                //                }
                //                tab.active = true;
                //            }
                //        }
                //
                //        //now add a hash for the active tab if none exists
                //        if ($scope.tabs.length > 0 && !$location.hash()) {
                //            console.log($scope.tabs[0]['title'])
                //            $location.hash($scope.tabs[0]['title']);
                //        }
                if (typeof $scope.onSchemaProcessed === "function") {
                    $scope.onSchemaProcessed(description, description.slice(0, 5) === 'Main ' ? $scope.baseSchema() : destForm);
                }
                if (destList && destList.length === 0) {
                    handleEmptyList(description, destList, destForm, source);
                }
            }
            function handleFieldType(formInstructions, mongooseType, mongooseOptions, $scope, ctrlState) {
                function performLookupSelect() {
                    formInstructions.options = recordHandler.suffixCleanId(formInstructions, 'Options');
                    formInstructions.ids = recordHandler.suffixCleanId(formInstructions, '_ids');
                    if (!formInstructions.hidden) {
                        if (mongooseOptions.ref) {
                            recordHandler.setUpLookupOptions(mongooseOptions.ref, formInstructions, $scope, ctrlState, handleSchema);
                        }
                        else if (mongooseOptions.lookupListRef) {
                            recordHandler.setUpLookupListOptions(mongooseOptions.lookupListRef, formInstructions, $scope, ctrlState);
                            formInstructions.lookupListRef = mongooseOptions.lookupListRef;
                        }
                        else if (mongooseOptions.internalRef) {
                            recordHandler.handleInternalLookup($scope, formInstructions, mongooseOptions.internalRef);
                            formInstructions.internalRef = mongooseOptions.internalRef;
                        }
                        else if (mongooseOptions.customLookupOptions) {
                            // nothing to do - call setUpCustomLookupOptions() when ready to provide id and option arrays
                        }
                        else {
                            throw new Error("No supported select lookup type found in ".concat(formInstructions.name));
                        }
                    }
                }
                if (mongooseType.caster) {
                    formInstructions.array = true;
                    mongooseType = mongooseType.caster;
                    angular.extend(mongooseOptions, mongooseType.options);
                    if (mongooseType.options && mongooseType.options.form) {
                        angular.extend(formInstructions, mongooseType.options.form);
                    }
                }
                if (mongooseType.instance === 'String') {
                    if (mongooseOptions.enum) {
                        formInstructions.type = formInstructions.type || 'select';
                        if (formInstructions.select2) {
                            console.log('support for fng-select2 has been removed in 0.8.3 - please convert to fng-ui-select');
                        }
                        else {
                            formInstructions.options = recordHandler.suffixCleanId(formInstructions, 'Options');
                            $scope[formInstructions.options] = mongooseOptions.enum;
                        }
                    }
                    else {
                        if (!formInstructions.type) {
                            formInstructions.type = (formInstructions.name.toLowerCase().indexOf('password') !== -1) ? 'password' : 'text';
                        }
                        if (mongooseOptions.match) {
                            formInstructions.add = 'pattern="' + mongooseOptions.match + '" ' + (formInstructions.add || '');
                        }
                    }
                }
                else if (mongooseType.instance === 'ObjectID') {
                    formInstructions.ref = mongooseOptions.ref;
                    if (formInstructions.link) {
                        if (formInstructions.link.linkOnly) {
                            formInstructions.type = 'link';
                            formInstructions.linktext = formInstructions.link.text;
                        }
                        else if (formInstructions.link.label) {
                            formInstructions.linklabel = true;
                        }
                        else {
                            console.log('Unsupported link setup');
                        }
                        formInstructions.form = formInstructions.link.form;
                        formInstructions.linktab = formInstructions.link.linktab;
                        delete formInstructions.link;
                    }
                    if (formInstructions.type !== 'link') {
                        formInstructions.type = 'select';
                        if (formInstructions.select2 || (mongooseOptions.form && mongooseOptions.form.select2)) {
                            console.log('support for fng-select2 has been removed in 0.8.3 - please convert to fng-ui-select');
                        }
                        else if ((!formInstructions.directive || (!formInstructions.noLookup && (!formInstructions[$filter('camelCase')(formInstructions.directive)] || !formInstructions[$filter('camelCase')(formInstructions.directive)].fngAjax)))) {
                            performLookupSelect();
                        }
                    }
                }
                else if (mongooseType.instance === 'Date') {
                    if (!formInstructions.type) {
                        formInstructions.intType = 'date';
                        if (formInstructions.readonly) {
                            formInstructions.type = 'text';
                        }
                        else if (formInstructions.directive) {
                            formInstructions.type = 'text';
                        }
                        else {
                            try {
                                formInstructions.add = formInstructions.add || '';
                                // Check whether DatePicker is installed
                                angular.module('ui.date').requires;
                                formInstructions.type = 'text';
                                formInstructions.add += ' ui-date ui-date-format ';
                                // formInstructions.add += ' ui-date ui-date-format datepicker-popup-fix ';
                            }
                            catch (e) {
                                formInstructions.type = 'date';
                                formInstructions.add += ' fng-naked-date="x" ';
                            }
                        }
                    }
                }
                else if (mongooseType.instance.toLowerCase() === 'boolean') {
                    formInstructions.type = formInstructions.type || 'checkbox';
                }
                else if (mongooseType.instance === 'Number') {
                    formInstructions.type = formInstructions.type || 'number';
                    if (mongooseOptions.min !== undefined) {
                        formInstructions.add = 'min="' + mongooseOptions.min + '" ' + (formInstructions.add || '');
                    }
                    if (mongooseOptions.max !== undefined) {
                        formInstructions.add = 'max="' + mongooseOptions.max + '" ' + (formInstructions.add || '');
                    }
                    if (formInstructions.step) {
                        formInstructions.add = 'step="' + formInstructions.step + '" ' + (formInstructions.add || '');
                    }
                }
                else {
                    throw new Error('Field ' + formInstructions.name + ' is of unsupported type ' + mongooseType.instance);
                }
                if (mongooseOptions.required) {
                    formInstructions.required = true;
                }
                if (mongooseOptions.readonly) {
                    formInstructions['readonly'] = true;
                }
                if (mongooseType.defaultValue !== undefined) {
                    formInstructions.defaultValue = mongooseType.defaultValue;
                }
                else if (mongooseType.options && mongooseType.options.default !== undefined) {
                    console.log('No support for default with no value, yet');
                }
                return formInstructions;
            }
            function getArrayFieldToExtend(fieldName, $scope, modelOverride) {
                var fieldParts = fieldName.split('.');
                var arrayField = modelOverride || $scope.record;
                for (var i = 0, l = fieldParts.length; i < l; i++) {
                    if (!arrayField[fieldParts[i]]) {
                        if (i === l - 1) {
                            arrayField[fieldParts[i]] = [];
                        }
                        else {
                            arrayField[fieldParts[i]] = {};
                        }
                    }
                    arrayField = arrayField[fieldParts[i]];
                }
                return arrayField;
            }
            // TODO: Do this in form
            var basicInstructions = function (field, formData, prefix) {
                formData.name = prefix + field;
                //        formData.id = formData.id || 'f_' + prefix + field.replace(/\./g, '_');
                //        formData.label = (formData.hasOwnProperty('label') && formData.label) == null ? '' : (formData.label || $filter('titleCase')(field));
                return formData;
            };
            var handleListInfo = function (destList, listOptions, field) {
                if (typeof listOptions === 'object') {
                    listOptions.name = field;
                    destList.push(listOptions);
                }
                else {
                    destList.push({ name: field });
                }
            };
            var handleEmptyList = function (description, destList, destForm, source) {
                // If no list fields specified use the first non hidden string field
                if (destForm) {
                    for (var i = 0, l = destForm.length; i < l; i++) {
                        if (destForm[i].type === 'text') {
                            destList.push({ name: destForm[i].name });
                            break;
                        }
                    }
                    if (destList.length === 0 && destForm.length !== 0) {
                        // If it is still blank then just use the first field
                        destList.push({ name: destForm[0].name });
                    }
                }
                if (destList.length === 0) {
                    // If it is still blank then just use the first field from source
                    for (var field in source) {
                        if (field !== '_id' && source.hasOwnProperty(field)) {
                            destList.push({ name: field });
                            break;
                        }
                    }
                    if (destList.length === 0) {
                        throw new Error('Unable to generate a title for ' + description);
                    }
                }
            };
            var evaluateConditional = function (condition, data) {
                function evaluateSide(side) {
                    var result = side;
                    if (typeof side === 'string' && side.slice(0, 1) === '$') {
                        var sideParts = side.split('.');
                        switch (sideParts.length) {
                            case 1:
                                result = recordHandler.getListData(data, side.slice(1));
                                break;
                            case 2:
                                // this is a sub schema element, and the appropriate array element has been passed
                                result = recordHandler.getListData(data, sideParts[1]);
                                break;
                            default:
                                throw new Error('Unsupported showIf format');
                        }
                    }
                    return result;
                }
                var lhs = evaluateSide(condition.lhs), rhs = evaluateSide(condition.rhs), result;
                switch (condition.comp) {
                    case 'eq':
                        result = (lhs === rhs);
                        break;
                    case 'ne':
                        result = (lhs !== rhs);
                        break;
                    default:
                        throw new Error('Unsupported comparator ' + condition.comp);
                }
                return result;
            };
            // Conditionals
            // $scope.dataDependencies is of the form {fieldName1: [fieldId1, fieldId2], fieldName2:[fieldId2]}
            var handleConditionals = function (condInst, name, $scope) {
                var dependency = 0;
                function handleVar(theVar) {
                    if (typeof theVar === 'string' && theVar.slice(0, 1) === '$') {
                        var fieldName = theVar.slice(1);
                        var fieldDependencies = $scope.dataDependencies[fieldName] || [];
                        fieldDependencies.push(name);
                        $scope.dataDependencies[fieldName] = fieldDependencies;
                        dependency += 1;
                    }
                }
                var display = true;
                if (condInst) {
                    handleVar(condInst.lhs);
                    handleVar(condInst.rhs);
                    if (dependency === 0 && !evaluateConditional(condInst, undefined)) {
                        display = false;
                    }
                }
                return display;
            };
            return {
                // utility for apps that use forms-angular
                generateEditUrl: function generateEditUrl(obj, $scope) {
                    return routingService.buildUrl($scope.modelName + '/' + ($scope.formName ? $scope.formName + '/' : '') + obj._id + '/edit');
                },
                generateViewUrl: function generateViewUrl(obj, $scope) {
                    return routingService.buildUrl($scope.modelName + '/' + ($scope.formName ? $scope.formName + '/' : '') + obj._id + '/view');
                },
                generateNewUrl: function generateNewUrl($scope) {
                    return routingService.buildUrl($scope.modelName + '/' + ($scope.formName ? $scope.formName + '/' : '') + 'new');
                },
                handleFieldType: handleFieldType,
                handleSchema: handleSchema,
                // Conventional view is that this should go in a directive.  I reckon it is quicker here.
                updateDataDependentDisplay: function updateDataDependentDisplay(curValue, oldValue, force, $scope) {
                    var depends, i, j, k, element;
                    var forceNextTime;
                    for (var field in $scope.dataDependencies) {
                        if ($scope.dataDependencies.hasOwnProperty(field)) {
                            var parts = field.split('.');
                            // TODO: what about a simple (non array) subdoc?
                            if (parts.length === 1) {
                                if (force || !oldValue || curValue[field] !== oldValue[field]) {
                                    depends = $scope.dataDependencies[field];
                                    for (i = 0; i < depends.length; i += 1) {
                                        var name = depends[i];
                                        for (j = 0; j < $scope.formSchema.length; j += 1) {
                                            if ($scope.formSchema[j].name === name) {
                                                element = angular.element(document.querySelector('#cg_' + $scope.formSchema[j].id));
                                                if (evaluateConditional($scope.formSchema[j].showIf, curValue)) {
                                                    element.removeClass('ng-hide');
                                                }
                                                else {
                                                    element.addClass('ng-hide');
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            else if (parts.length === 2) {
                                if (forceNextTime === undefined) {
                                    forceNextTime = true;
                                }
                                if (curValue[parts[0]]) {
                                    for (k = 0; k < curValue[parts[0]].length; k++) {
                                        // We want to carry on if this is new array element or it is changed
                                        if (force || !oldValue || !oldValue[parts[0]] || !oldValue[parts[0]][k] || curValue[parts[0]][k][parts[1]] !== oldValue[parts[0]][k][parts[1]]) {
                                            depends = $scope.dataDependencies[field];
                                            for (i = 0; i < depends.length; i += 1) {
                                                var nameParts = depends[i].split('.');
                                                if (nameParts.length !== 2) {
                                                    throw new Error('Conditional display must control dependent fields at same level ');
                                                }
                                                for (j = 0; j < $scope.formSchema.length; j += 1) {
                                                    if ($scope.formSchema[j].name === nameParts[0]) {
                                                        var subSchema = $scope.formSchema[j].schema;
                                                        for (var l = 0; l < subSchema.length; l++) {
                                                            if (subSchema[l].name === depends[i]) {
                                                                element = angular.element(document.querySelector('#f_' + nameParts[0] + 'List_' + k + ' #cg_f_' + depends[i].replace('.', '_')));
                                                                if (element.length === 0) {
                                                                    // Test Plait care plan structures if you change next line
                                                                    element = angular.element(document.querySelector('#f_elements-' + k + '-' + nameParts[1]));
                                                                }
                                                                else {
                                                                    forceNextTime = false; // Because the sub schema has been rendered we don't need to do this again until the record changes
                                                                }
                                                                if (element.length > 0) {
                                                                    if (evaluateConditional($scope.formSchema[j].schema[l].showIf, curValue[parts[0]][k])) {
                                                                        element.show();
                                                                    }
                                                                    else {
                                                                        element.hide();
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            else {
                                // TODO: this needs rewrite for nesting
                                throw new Error('You can only go down one level of subdocument with showIf');
                            }
                        }
                    }
                    return forceNextTime;
                },
                add: function add(fieldName, $event, $scope, modelOverride) {
                    var _a;
                    // check that target element is visible.  May not be reliable - see https://stackoverflow.com/questions/19669786/check-if-element-is-visible-in-dom
                    if ($event.target.offsetParent) {
                        var arrayField = getArrayFieldToExtend(fieldName, $scope, modelOverride);
                        var schemaElement = $scope.formSchema.find(function (f) { return f.name === fieldName; }); // In case someone is using the formSchema directly
                        var subSchema = schemaElement ? schemaElement.schema : null;
                        var obj = subSchema ? $scope.setDefaults(subSchema, fieldName + '.') : {};
                        if (typeof ((_a = $scope.dataEventFunctions) === null || _a === void 0 ? void 0 : _a.onInitialiseNewSubDoc) === "function") {
                            $scope.dataEventFunctions.onInitialiseNewSubDoc(fieldName, subSchema, obj);
                        }
                        arrayField.push(obj);
                        $scope.setFormDirty($event);
                    }
                },
                unshift: function unshift(fieldName, $event, $scope, modelOverride) {
                    var arrayField = getArrayFieldToExtend(fieldName, $scope, modelOverride);
                    arrayField.unshift({});
                    $scope.setFormDirty($event);
                },
                remove: function remove(fieldName, value, $event, $scope, modelOverride) {
                    // Remove an element from an array
                    var arrayField = getArrayFieldToExtend(fieldName, $scope, modelOverride);
                    var err;
                    if (typeof $scope.dataEventFunctions.onDeleteSubDoc === "function") {
                        var schemaElement = $scope.formSchema.find(function (f) {
                            return f.name === fieldName;
                        });
                        var subSchema = schemaElement ? schemaElement.schema : null;
                        err = $scope.dataEventFunctions.onDeleteSubDoc(fieldName, subSchema, arrayField, value);
                    }
                    if (err) {
                        $scope.showError(err);
                    }
                    else {
                        arrayField.splice(value, 1);
                        $scope.setFormDirty($event);
                    }
                },
                hasError: function hasError(formName, name, index, $scope) {
                    var result = false;
                    if ($scope) {
                        var form = $scope[$scope.topLevelFormName];
                        if (formName !== 'null') {
                            form = form[formName.replace('$index', index)];
                        }
                        // Cannot assume that directives will use the same methods
                        if (form) {
                            var field_1 = form[name];
                            if (field_1 && field_1.$invalid && !field_1.$$attr.readonly) {
                                if (field_1.$dirty) {
                                    result = true;
                                }
                                else {
                                    // with pristine fields, they have to have some sort of invalidity other than ng-invalid-required
                                    angular.forEach(field_1.$validators, function (obj, key) {
                                        if (key !== 'required' && field_1.$error[key]) {
                                            result = true;
                                        }
                                    });
                                }
                            }
                        }
                    }
                    else {
                        console.log('hasError called with no scope! ', formName, name, index);
                    }
                    return result;
                },
                decorateScope: function decorateScope($scope, formGeneratorInstance, recordHandlerInstance, sharedData) {
                    $scope.record = sharedData.record;
                    $scope.phase = 'init';
                    $scope.disableFunctions = sharedData.disableFunctions;
                    $scope.dataEventFunctions = sharedData.dataEventFunctions;
                    $scope.topLevelFormName = undefined;
                    $scope.formSchema = [];
                    $scope.tabs = [];
                    $scope.listSchema = [];
                    $scope.recordList = [];
                    $scope.dataDependencies = {};
                    $scope.internalLookups = [];
                    $scope.listLookups = [];
                    $scope.conversions = {};
                    $scope.pageSize = 60;
                    $scope.pagesLoaded = 0;
                    sharedData.baseScope = $scope;
                    $scope.generateEditUrl = function (obj) {
                        return formGeneratorInstance.generateEditUrl(obj, $scope);
                    };
                    $scope.generateViewUrl = function (obj) {
                        return formGeneratorInstance.generateViewUrl(obj, $scope);
                    };
                    $scope.generateNewUrl = function () {
                        return formGeneratorInstance.generateNewUrl($scope);
                    };
                    $scope.scrollTheList = function () {
                        return recordHandlerInstance.scrollTheList($scope);
                    };
                    $scope.getListData = function (record, fieldName) {
                        return recordHandlerInstance.getListData(record, fieldName, $scope.listSchema, $scope);
                    };
                    $scope.setPristine = function (clearErrors) {
                        if (clearErrors) {
                            $scope.dismissError();
                        }
                        if ($scope[$scope.topLevelFormName]) {
                            $scope[$scope.topLevelFormName].$setPristine();
                        }
                    };
                    $scope.skipCols = function (index) {
                        return index > 0 ? 'col-md-offset-3' : '';
                    };
                    $scope.setFormDirty = function (event) {
                        if (event) {
                            var form = angular.element(event.target).inheritedData('$formController');
                            form.$setDirty();
                        }
                        else {
                            console.log('setFormDirty called without an event (fine in a unit test)');
                        }
                    };
                    $scope.add = function (fieldName, $event, modelOverride) {
                        return formGeneratorInstance.add(fieldName, $event, $scope, modelOverride);
                    };
                    $scope.hasError = function (form, name, index) {
                        return formGeneratorInstance.hasError(form, name, index, $scope);
                    };
                    $scope.unshift = function (fieldName, $event, modelOverride) {
                        return formGeneratorInstance.unshift(fieldName, $event, $scope, modelOverride);
                    };
                    $scope.remove = function (fieldName, value, $event, modelOverride) {
                        return formGeneratorInstance.remove(fieldName, value, $event, $scope, modelOverride);
                    };
                    $scope.baseSchema = function () {
                        return ($scope.tabs.length ? $scope.tabs : $scope.formSchema);
                    };
                    // TODO Figure out tab history updates (check for other tab-history-todos)
                    // $scope.tabDeselect = function($event, $selectedIndex) {
                    //   if (!$scope.newRecord) {
                    //     $location.path(routingService.buildUrl($scope.modelName + '/' + ($scope.formName ? $scope.formName + '/' : '') + $scope.record._id + '/edit/' + $event.target.text));
                    //   }
                    // }
                }
            };
        }
        services.formGenerator = formGenerator;
        formGenerator.$inject = ["$location", "$timeout", "$filter", "routingService", "recordHandler"];
    })(services = fng.services || (fng.services = {}));
})(fng || (fng = {}));
/// <reference path="../../index.d.ts" />
var fng;
(function (fng) {
    var services;
    (function (services) {
        /*@ngInject*/
        formMarkupHelper.$inject = ["cssFrameworkService", "inputSizeHelper", "addAllService", "$filter"];
        function formMarkupHelper(cssFrameworkService, inputSizeHelper, addAllService, $filter) {
            function generateNgShow(showWhen, model) {
                function evaluateSide(side) {
                    var result = side;
                    if (typeof side === 'string') {
                        if (side.slice(0, 1) === '$') {
                            result = (model || 'record') + '.';
                            var parts = side.slice(1).split('.');
                            if (parts.length > 1) {
                                var lastBit = parts.pop();
                                result += parts.join('.') + '[$index].' + lastBit;
                            }
                            else {
                                result += side.slice(1);
                            }
                        }
                        else {
                            result = '\'' + side + '\'';
                        }
                    }
                    return result;
                }
                var conditionText = ['eq', 'ne', 'gt', 'gte', 'lt', 'lte'], conditionSymbols = ['===', '!==', '>', '>=', '<', '<='], conditionPos = conditionText.indexOf(showWhen.comp);
                if (conditionPos === -1) {
                    throw new Error('Invalid comparison in showWhen');
                }
                return evaluateSide(showWhen.lhs) + conditionSymbols[conditionPos] + evaluateSide(showWhen.rhs);
            }
            var isHorizontalStyle = function isHorizontalStyle(formStyle, includeStacked) {
                var exclude = ['vertical', 'inline'];
                if (!includeStacked) {
                    exclude.push('stacked');
                }
                return (!formStyle || formStyle === 'undefined' || !exclude.includes(formStyle));
            };
            function glyphClass() {
                return (cssFrameworkService.framework() === 'bs2' ? 'icon' : 'glyphicon glyphicon');
            }
            return {
                isHorizontalStyle: isHorizontalStyle,
                fieldChrome: function fieldChrome(scope, info, options) {
                    var classes = info.classes || '';
                    var template = '';
                    var closeTag = '';
                    var insert = '';
                    info.showWhen = info.showWhen || info.showwhen; //  deal with use within a directive
                    if (info.showWhen) {
                        if (typeof info.showWhen === 'string') {
                            insert += 'ng-show="' + info.showWhen + '"';
                        }
                        else {
                            insert += 'ng-show="' + generateNgShow(info.showWhen, options.model) + '"';
                        }
                    }
                    if (info.id && typeof info.id.replace === "function") {
                        insert += ' id="cg_' + info.id.replace(/\./g, '-') + '"';
                    }
                    if (cssFrameworkService.framework() === 'bs3') {
                        classes += ' form-group';
                        if (options.formstyle === 'vertical' && info.size !== 'block-level') {
                            template += '<div class="row">';
                            classes += ' col-sm-' + inputSizeHelper.sizeAsNumber(info.size);
                            closeTag += '</div>';
                        }
                        var modelControllerName;
                        var formName = null;
                        var parts = info.name.split('.');
                        if (options && typeof options.subkeyno !== 'undefined') {
                            modelControllerName = options.subschemaroot.replace(/\./g, '-') + '-subkey' + options.subkeyno + '-' + parts[parts.length - 1];
                        }
                        else if (options.subschema) {
                            formName = 'form_' + parts.slice(0, -1).join('_') + '$index';
                            modelControllerName = info.name.replace(/\./g, '-');
                        }
                        else {
                            modelControllerName = 'f_' + info.name.replace(/\./g, '_');
                        }
                        template += '<div' + addAllService.addAll(scope, 'Group', classes, options) + ' ng-class="{\'has-error\': hasError(\'' + formName + '\',\'' + modelControllerName + '\', $index)}"';
                        closeTag += '</div>';
                    }
                    else {
                        if (isHorizontalStyle(options.formstyle, true)) {
                            template += '<div' + addAllService.addAll(scope, 'Group', 'control-group', options);
                            closeTag = '</div>';
                        }
                        else {
                            template += '<span ';
                            closeTag = '</span>';
                        }
                    }
                    template += (insert || '') + '>';
                    return { template: template, closeTag: closeTag };
                },
                label: function label(scope, fieldInfo, addButtonMarkup, options) {
                    var labelHTML = '';
                    if ((cssFrameworkService.framework() === 'bs3' || (!['inline', 'stacked'].includes(options.formstyle) && fieldInfo.label !== '')) || addButtonMarkup) {
                        labelHTML = '<label';
                        var classes = 'control-label';
                        if (isHorizontalStyle(options.formstyle, false)) {
                            if (!fieldInfo.linklabel) {
                                labelHTML += ' for="' + fieldInfo.id + '"';
                            }
                            if (typeof fieldInfo.labelDefaultClass !== 'undefined') {
                                // Override default label class (can be empty)
                                classes += ' ' + fieldInfo.labelDefaultClass;
                            }
                            else if (cssFrameworkService.framework() === 'bs3') {
                                classes += ' col-sm-3';
                            }
                        }
                        else if (['inline', 'stacked'].includes(options.formstyle)) {
                            labelHTML += ' for="' + fieldInfo.id + '"';
                            classes += ' sr-only';
                        }
                        labelHTML += addAllService.addAll(scope, 'Label', null, options) + ' class="' + classes + '">' + fieldInfo.label;
                        if (addButtonMarkup) {
                            labelHTML += ' <i id="add_' + fieldInfo.id + '" ng-click="add(\'' + fieldInfo.name + '\',$event)" class="' + glyphClass() + '-plus-sign"></i>';
                        }
                        labelHTML += '</label>';
                        if (fieldInfo.linklabel) {
                            var value = '<fng-link fld="' + fieldInfo.name + '" ref="' + fieldInfo.ref + '" text="' + escape(labelHTML) + '"';
                            if (fieldInfo.form) {
                                value += ' form="' + fieldInfo.form + '"';
                            }
                            if (fieldInfo.linktab) {
                                value += ' linktab="' + fieldInfo.linktab + '"';
                            }
                            value += '></fng-link>';
                            labelHTML = value;
                        }
                    }
                    return labelHTML;
                },
                glyphClass: glyphClass,
                allInputsVars: function allInputsVars(scope, fieldInfo, options, modelString, idString, nameString) {
                    var placeHolder = fieldInfo.placeHolder;
                    var common;
                    var compactClass = '';
                    var sizeClassBS3 = '';
                    var sizeClassBS2 = '';
                    var formControl = '';
                    if (cssFrameworkService.framework() === 'bs3') {
                        compactClass = (['horizontal', 'vertical', 'inline'].indexOf(options.formstyle) === -1) ? ' input-sm' : '';
                        sizeClassBS3 = 'col-sm-' + inputSizeHelper.sizeAsNumber(fieldInfo.size);
                        formControl = ' form-control';
                    }
                    else {
                        sizeClassBS2 = (fieldInfo.size ? ' input-' + fieldInfo.size : '');
                    }
                    if (['inline', 'stacked'].includes(options.formstyle)) {
                        placeHolder = placeHolder || fieldInfo.label;
                    }
                    common = 'data-ng-model="' + modelString + '"' + (idString ? ' id="' + idString + '" name="' + idString + '" ' : ' name="' + nameString + '" ');
                    common += (placeHolder ? ('placeholder="' + placeHolder + '" ') : '');
                    if (fieldInfo.popup) {
                        common += 'title="' + fieldInfo.popup + '" ';
                    }
                    if (fieldInfo.ariaLabel) {
                        common += 'aria-label="' + fieldInfo.ariaLabel + '" ';
                    }
                    common += addAllService.addAll(scope, 'Field', null, options);
                    return {
                        common: common,
                        sizeClassBS3: sizeClassBS3,
                        sizeClassBS2: sizeClassBS2,
                        compactClass: compactClass,
                        formControl: formControl
                    };
                },
                inputChrome: function inputChrome(value, fieldInfo, options, markupVars) {
                    if (cssFrameworkService.framework() === 'bs3' && isHorizontalStyle(options.formstyle, true) && fieldInfo.type !== 'checkbox') {
                        value = '<div class="bs3-input ' + markupVars.sizeClassBS3 + '">' + value + '</div>';
                    }
                    // Hack to cope with inline help in directives
                    var inlineHelp = (fieldInfo.helpInline || '') + (fieldInfo.helpinline || '');
                    if (inlineHelp.length > 0) {
                        var helpMarkup = cssFrameworkService.framework() === 'bs2' ? { el: 'span', cl: 'help-inline' } : { el: 'div', cl: 'help-block' };
                        value += "<".concat(helpMarkup.el, " class=\"").concat(helpMarkup.cl, "\">").concat(inlineHelp, "</").concat(helpMarkup.el, ">");
                    }
                    if (!options.noid) {
                        value += "<div ng-if=\"".concat((options.name || 'myForm'), "['").concat(fieldInfo.id, "'].$dirty\" class=\"help-block\">") +
                            " <div ng-messages=\"".concat((options.name || 'myForm'), "['").concat(fieldInfo.id, "'].$error\">") +
                            '  <div ng-messages-include="error-messages.html">' +
                            '  </div>' +
                            ' </div>' +
                            '</div>';
                    }
                    if (fieldInfo.help) {
                        value += '<div class="help-block">' + fieldInfo.help + '</div>';
                    }
                    return value;
                },
                generateSimpleInput: function generateSimpleInput(common, fieldInfo, options) {
                    var result = '<input ' + common + 'type="' + fieldInfo.type + '" ';
                    if (!fieldInfo.label && !fieldInfo.ariaLabel) {
                        result += "aria-label=\"".concat(fieldInfo.name.replace(/\./g, ' '), "\" ");
                    }
                    else if (options.subschema) {
                        result += "aria-label=\"".concat(fieldInfo.label ? ($filter('titleCase')(options.subschemaroot) + ' ' + fieldInfo.label) : (fieldInfo.popup || fieldInfo.name.replace(/\./g, ' ')), "\" ");
                    }
                    if (options.formstyle === 'inline' && cssFrameworkService.framework() === 'bs2' && !fieldInfo.size) {
                        result += 'class="input-small"';
                    }
                    result += ' />';
                    return result;
                },
                controlDivClasses: function controlDivClasses(options) {
                    var result = [];
                    if (isHorizontalStyle(options.formstyle, false)) {
                        result.push(cssFrameworkService.framework() === 'bs2' ? 'controls' : 'col-sm-9');
                    }
                    return result;
                },
                handleInputAndControlDiv: function handleInputAndControlDiv(inputMarkup, controlDivClasses) {
                    if (controlDivClasses.length > 0) {
                        inputMarkup = '<div class="' + controlDivClasses.join(' ') + '">' + inputMarkup + '</div>';
                    }
                    return inputMarkup;
                },
                handleArrayInputAndControlDiv: function handleArrayInputAndControlDiv(inputMarkup, controlDivClasses, info, options) {
                    var result = '<div ';
                    if (cssFrameworkService.framework() === 'bs3') {
                        result += 'ng-class="skipCols($index)" ';
                    }
                    result += 'class="' + controlDivClasses.join(' ') + '" id="' + info.id + 'List" ';
                    result += 'ng-repeat="arrayItem in ' + (options.model || 'record') + '.' + info.name + ' track by $index">';
                    result += inputMarkup;
                    if (info.type !== 'link') {
                        result += '<i ng-click="remove(\'' + info.name + '\',$index,$event)" id="remove_' + info.id + '_{{$index}}" class="' + glyphClass() + '-minus-sign"></i>';
                    }
                    result += '</div>';
                    return result;
                },
                addTextInputMarkup: function addTextInputMarkup(allInputsVars, fieldInfo, requiredStr) {
                    var result = '';
                    var setClass = allInputsVars.formControl.trim() + allInputsVars.compactClass + allInputsVars.sizeClassBS2 + (fieldInfo.class ? ' ' + fieldInfo.class : '');
                    if (setClass.length !== 0) {
                        result += 'class="' + setClass + '"';
                    }
                    if (fieldInfo.add) {
                        result += ' ' + fieldInfo.add + ' ';
                    }
                    result += requiredStr;
                    if (fieldInfo.readonly) {
                        result += " ".concat(typeof fieldInfo.readOnly === 'boolean' ? 'readonly' : 'ng-readonly="' + fieldInfo.readonly + '"', " ");
                    }
                    else {
                        result += ' ';
                    }
                    return result;
                }
            };
        }
        services.formMarkupHelper = formMarkupHelper;
    })(services = fng.services || (fng.services = {}));
})(fng || (fng = {}));
/// <reference path="../../../../node_modules/@types/angular/index.d.ts" />
var fng;
(function (fng) {
    var services;
    (function (services) {
        /*@ngInject*/
        function inputSizeHelper() {
            var sizeMapping = [1, 2, 4, 6, 8, 10, 12];
            var sizeDescriptions = ['mini', 'small', 'medium', 'large', 'xlarge', 'xxlarge', 'block-level'];
            var defaultSizeOffset = 2; // medium, which was the default for Twitter Bootstrap 2
            return {
                sizeMapping: sizeMapping,
                sizeDescriptions: sizeDescriptions,
                defaultSizeOffset: defaultSizeOffset,
                sizeAsNumber: function (fieldSizeAsText) {
                    return sizeMapping[fieldSizeAsText ? sizeDescriptions.indexOf(fieldSizeAsText) : defaultSizeOffset];
                }
            };
        }
        services.inputSizeHelper = inputSizeHelper;
    })(services = fng.services || (fng.services = {}));
})(fng || (fng = {}));
/// <reference path="../../../../node_modules/@types/angular/index.d.ts" />
var fng;
(function (fng) {
    var services;
    (function (services) {
        /*
         A helper service to provide a starting off point for directive plugins
         */
        /*@ngInject*/
        pluginHelper.$inject = ["formMarkupHelper"];
        function pluginHelper(formMarkupHelper) {
            return {
                extractFromAttr: function extractFromAttr(attr, directiveName) {
                    function deserialize(str) {
                        var retVal = str.replace(/&quot;/g, '"');
                        if (retVal === 'true') {
                            retVal = true;
                        }
                        else if (retVal === 'false') {
                            retVal = false;
                        }
                        else if (!isNaN(parseFloat(retVal)) && isFinite(retVal)) {
                            retVal = parseFloat(retVal);
                        }
                        return retVal;
                    }
                    var info = {};
                    var options = { formStyle: attr.formstyle };
                    var directiveOptions = {};
                    var directiveNameLength = directiveName ? directiveName.length : 0;
                    var lcDirectiveName = directiveName === null || directiveName === void 0 ? void 0 : directiveName.toLowerCase();
                    for (var prop in attr) {
                        if (attr.hasOwnProperty(prop)) {
                            var lcProp = prop.toLowerCase();
                            if (lcProp.slice(0, 6) === 'fngfld') {
                                info[lcProp.slice(6)] = deserialize(attr[prop]);
                            }
                            else if (lcProp.slice(0, 6) === 'fngopt') {
                                options[lcProp.slice(6)] = deserialize(attr[prop]);
                            }
                            else if (directiveName && lcProp.slice(0, directiveNameLength) === lcDirectiveName) {
                                directiveOptions[_.kebabCase(prop.slice(directiveNameLength))] = deserialize(attr[prop]);
                            }
                        }
                    }
                    return { info: info, options: options, directiveOptions: directiveOptions };
                },
                buildInputMarkup: function buildInputMarkup(scope, model, info, options, addButtons, needsX, generateInputControl) {
                    var fieldChrome = formMarkupHelper.fieldChrome(scope, info, options, ' id="cg_' + info.id + '"');
                    var controlDivClasses = formMarkupHelper.controlDivClasses(options);
                    var elementHtml = fieldChrome.template + formMarkupHelper.label(scope, info, addButtons, options);
                    var modelString, idString, nameString;
                    if (addButtons) {
                        modelString = 'arrayItem' + (needsX ? '.x' : '');
                        idString = info.id + '_{{$index}}';
                        nameString = info.name + '_{{$index}}';
                    }
                    else {
                        modelString = model + '.' + info.name;
                        idString = info.id;
                        nameString = info.name;
                    }
                    if (options.subschema && info.name.indexOf('.') !== -1) {
                        // Schema handling - need to massage the ngModel and the id
                        var modelBase = model + '.';
                        var compoundName = info.name;
                        var root = options.subschemaroot;
                        var lastPart = compoundName.slice(root.length + 1);
                        modelString = modelBase;
                        if (options.index) {
                            modelString += root + '[' + options.index + '].' + lastPart;
                            idString = 'f_' + modelString.slice(modelBase.length).replace(/(\.|\[|\]\.)/g, '-');
                        }
                        else {
                            modelString += root;
                            if (options.subkey) {
                                idString = modelString.slice(modelBase.length).replace(/\./g, '-') + '-subkey' + options.subkeyno + '-' + lastPart;
                                modelString += '[' + '$_arrayOffset_' + root.replace(/\./g, '_') + '_' + options.subkeyno + '].' + lastPart;
                            }
                            else {
                                modelString += '[$index].' + lastPart;
                                idString = null;
                                nameString = compoundName.replace(/\./g, '-');
                            }
                        }
                    }
                    var buildingBlocks = formMarkupHelper.allInputsVars(scope, info, options, modelString, idString, nameString);
                    buildingBlocks.modelString = modelString;
                    elementHtml += formMarkupHelper['handle' + (addButtons ? 'Array' : '') + 'InputAndControlDiv'](formMarkupHelper.inputChrome(generateInputControl(buildingBlocks), info, options, buildingBlocks), controlDivClasses, info, options);
                    elementHtml += fieldChrome.closeTag;
                    return elementHtml;
                },
                findIdInSchemaAndFlagNeedX: function findIdInSchemaAndFlagNeedX(scope, id) {
                    // Find the entry in the schema of scope for id and add a needsX property so string arrays are properly handled
                    var foundIt = false;
                    for (var i = 0; i < scope.length; i++) {
                        var element = scope[i];
                        if (element.id === id) {
                            element.needsX = true;
                            foundIt = true;
                            break;
                        }
                        else if (element.schema) {
                            if (findIdInSchemaAndFlagNeedX(element.schema, id)) {
                                foundIt = true;
                                break;
                            }
                        }
                    }
                    return foundIt;
                }
            };
        }
        services.pluginHelper = pluginHelper;
    })(services = fng.services || (fng.services = {}));
})(fng || (fng = {}));
/// <reference path="../../index.d.ts" />
var fng;
(function (fng) {
    var services;
    (function (services) {
        /**
         * Operations on a whole record
         *
         * All methods should be state-less
         *
         */
        /*@ngInject*/
        recordHandler.$inject = ["$location", "$window", "$filter", "$timeout", "routingService", "cssFrameworkService", "SubmissionsService", "SchemasService"];
        function recordHandler($location, $window, $filter, $timeout, routingService, cssFrameworkService, SubmissionsService, SchemasService) {
            // TODO: Put this in a service
            var makeMongoId = function (rnd) {
                if (rnd === void 0) { rnd = function (r16) { return Math.floor(r16).toString(16); }; }
                return rnd(Date.now() / 1000) + " ".repeat(16).replace(/./g, function () { return rnd(Math.random() * 16); });
            };
            function _handleCancel(resp) {
                if (["cancel", "backdrop click", "escape key press"].indexOf(resp) === -1) {
                    throw resp;
                }
            }
            var suffixCleanId = function suffixCleanId(inst, suffix) {
                return (inst.id || "f_" + inst.name).replace(/\./g, "_") + suffix;
            };
            var walkTree = function (object, fieldname, element, insertIntermediateObjects) {
                // Walk through subdocs to find the required key
                // for instance walkTree(master,'address.street.number',element)
                // called by getData and setData
                if (insertIntermediateObjects === void 0) { insertIntermediateObjects = false; }
                // element is used when accessing in the context of a input, as the id (like exams-2-grader)
                // gives us the element of an array (one level down only for now).  Leaving element blank returns the whole array
                var parts = fieldname.split("."), higherLevels = parts.length - 1, workingRec = object;
                for (var i = 0; i < higherLevels; i++) {
                    if (!workingRec) {
                        throw new Error("walkTree failed: Object = ".concat(object, ", fieldname = ").concat(fieldname, ", i = ").concat(i));
                    }
                    if (angular.isArray(workingRec)) {
                        workingRec = _.map(workingRec, function (obj) {
                            return obj[parts[i]];
                        });
                    }
                    else {
                        if (insertIntermediateObjects && !workingRec[parts[i]]) {
                            workingRec[parts[i]] = {};
                        }
                        workingRec = workingRec[parts[i]];
                    }
                    if (angular.isArray(workingRec) && typeof element !== "undefined") {
                        if (element.scope && typeof element.scope === "function") {
                            // If we come across an array we need to find the correct position, if we have an element
                            workingRec = workingRec[element.scope().$index];
                        }
                        else if (typeof element === "number") {
                            workingRec = workingRec[element];
                        }
                        else {
                            throw new Error("Unsupported element type in walkTree " + fieldname);
                        }
                    }
                    if (!workingRec) {
                        break;
                    }
                }
                return {
                    lastObject: workingRec,
                    key: workingRec ? parts[higherLevels] : undefined
                };
            };
            var setData = function setData(object, fieldname, element, value) {
                var leafData = walkTree(object, fieldname, element, !!value);
                if (leafData.lastObject && leafData.key) {
                    if (value) {
                        if (angular.isArray(leafData.lastObject)) {
                            for (var i = 0; i < leafData.lastObject.length; i++) {
                                leafData.lastObject[i][leafData.key] = value[i];
                            }
                        }
                        else {
                            leafData.lastObject[leafData.key] = value;
                        }
                    }
                    else {
                        delete leafData.lastObject[leafData.key];
                    }
                }
            };
            var getData = function (object, fieldname, element) {
                var leafData = walkTree(object, fieldname, element);
                var retVal;
                if (leafData.lastObject && leafData.key) {
                    if (angular.isArray(leafData.lastObject)) {
                        retVal = _.map(leafData.lastObject, function (obj) {
                            return obj[leafData.key];
                        });
                    }
                    else {
                        retVal = leafData.lastObject[leafData.key];
                    }
                }
                return retVal;
            };
            var updateRecordWithLookupValues = function (schemaElement, $scope, ctrlState, ignoreDirty) {
                if (ignoreDirty === void 0) { ignoreDirty = false; }
                // Update the master and the record with the lookup values, master first
                if (!$scope.topLevelFormName || ($scope[$scope.topLevelFormName] && (ignoreDirty || $scope[$scope.topLevelFormName].$pristine))) {
                    updateObject(schemaElement.name, ctrlState.master, function (value) {
                        if (typeof value == "object" && value.id) {
                            return value;
                        }
                        else {
                            return convertForeignKeys(schemaElement, value, $scope[suffixCleanId(schemaElement, "Options")], $scope[suffixCleanId(schemaElement, "_ids")]);
                        }
                    });
                    // Then copy the converted keys from master into record
                    var newVal = getData(ctrlState.master, schemaElement.name);
                    if (newVal) {
                        setData($scope.record, schemaElement.name, undefined, newVal);
                    }
                }
            };
            // Split a field name into the next level and all following levels
            function splitFieldName(aFieldName) {
                var nesting = aFieldName.split("."), result = [nesting[0]];
                if (nesting.length > 1) {
                    result.push(nesting.slice(1).join("."));
                }
                return result;
            }
            var getListData = function getListData(record, fieldName, listSchema, $scope) {
                if (listSchema === void 0) { listSchema = null; }
                var retVal = getData(record, fieldName) || "";
                if (retVal && listSchema) {
                    // Convert list fields as per instructions in params (ideally should be the same as what is found in data_form getListFields
                    var schemaElm = _.find(listSchema, function (elm) { return (elm["name"] === fieldName); });
                    if (schemaElm) {
                        switch (schemaElm["params"]) {
                            case undefined:
                                break;
                            case "timestamp":
                                var timestamp = retVal.toString().substring(0, 8);
                                var date = new Date(parseInt(timestamp, 16) * 1000);
                                retVal = date.toLocaleDateString() + " " + date.toLocaleTimeString();
                                break;
                            default:
                                retVal = $scope.dataEventFunctions[schemaElm["params"]](record);
                        }
                    }
                }
                return retVal;
            };
            function updateObject(aFieldName, portion, fn) {
                var fieldDetails = splitFieldName(aFieldName);
                if (fieldDetails.length > 1) {
                    updateArrayOrObject(fieldDetails[1], portion[fieldDetails[0]], fn);
                }
                else if (portion[fieldDetails[0]]) {
                    var theValue = portion[fieldDetails[0]];
                    // Strip out empty objects here (in case anyone added to an array and didn't populate it)
                    if (angular.isArray(theValue)) {
                        for (var i = theValue.length - 1; i >= 0; i--) {
                            var type = typeof theValue[i];
                            if (type === "undefined" || (type === "object" && Object.keys(theValue[i]).length === 0)) {
                                theValue.splice(i, 1);
                            }
                        }
                    }
                    portion[fieldDetails[0]] = fn(theValue);
                }
            }
            function updateArrayOrObject(aFieldName, portion, fn) {
                if (portion !== undefined) {
                    if (angular.isArray(portion)) {
                        for (var i = 0; i < portion.length; i++) {
                            updateObject(aFieldName, portion[i], fn);
                        }
                    }
                    else {
                        updateObject(aFieldName, portion, fn);
                    }
                }
            }
            // Set up the lookup lists (value and id) on the scope for an internal lookup.  Called by convertToAngularModel and $watch
            function setUpInternalLookupLists($scope, options, ids, newVal, valueAttrib) {
                var optionsArray = (typeof options === "string" ? $scope[options] : options);
                var idsArray = (typeof ids === "string" ? $scope[ids] : ids);
                optionsArray.length = 0;
                idsArray.length = 0;
                if (!!newVal && (newVal.length > 0)) {
                    newVal.forEach(function (a) {
                        var value = a[valueAttrib];
                        if (value && value.length > 0) {
                            optionsArray.push(value);
                            if (!a._id) {
                                a._id = makeMongoId();
                            }
                            idsArray.push(a._id);
                        }
                    });
                }
            }
            var simpleArrayNeedsX = function (aSchema) {
                var result = false;
                if (aSchema.needsX) {
                    result = true;
                }
                else if (!aSchema.directive) {
                    if (aSchema.type === "text") {
                        result = true;
                    }
                    else if (aSchema.type === "select" && !aSchema.ids) {
                        result = true;
                    }
                }
                return result;
            };
            /* Look up a conversion set up by a plugin */
            function getConversionObject(scope, entryName, schemaName) {
                var conversions = scope.conversions;
                if (schemaName) {
                    conversions = getData(conversions, schemaName) || {};
                }
                return conversions[entryName];
            }
            // Convert mongodb json to what we use in the browser, for example {_id:'xxx', array:['item 1'], lookup:'012abcde'} to {_id:'xxx', array:[{x:'item 1'}], lookup:'List description for 012abcde'}
            // This will currently only work for a single level of nesting (conversionObject will not go down further without amendment, and offset needs to be an array, at least)
            var convertToAngularModel = function (schema, anObject, prefixLength, $scope, schemaName, master, offset) {
                master = master || anObject;
                for (var i = 0; i < schema.length; i++) {
                    var schemaEntry = schema[i];
                    var fieldName = schemaEntry.name.slice(prefixLength);
                    if (!fieldName.length) {
                        fieldName = schemaEntry.name.split('.').pop();
                    }
                    var fieldValue = getData(anObject, fieldName);
                    if (schemaEntry.intType === 'date' && typeof fieldValue === 'string') {
                        setData(anObject, fieldName, null, new Date(fieldValue));
                    }
                    if (schemaEntry.schema) {
                        if (fieldValue) {
                            for (var j = 0; j < fieldValue.length; j++) {
                                fieldValue[j] = convertToAngularModel(schemaEntry.schema, fieldValue[j], 1 + fieldName.length, $scope, fieldName, master, j);
                            }
                        }
                    }
                    else {
                        if (schemaEntry.internalRef) {
                            setUpInternalLookupLists($scope, schemaEntry.options, schemaEntry.ids, master[schemaEntry.internalRef.property], schemaEntry.internalRef.value);
                        }
                        // Convert {array:['item 1']} to {array:[{x:'item 1'}]}
                        var thisField = getListData(anObject, fieldName, null, $scope);
                        if (schemaEntry.array &&
                            simpleArrayNeedsX(schemaEntry) &&
                            thisField &&
                            !(thisField.length > 0 && thisField[0].x) // Don't keep on coverting
                        ) {
                            for (var k = 0; k < thisField.length; k++) {
                                thisField[k] = { x: thisField[k] };
                            }
                        }
                        // Convert {lookup:'012abcde'} to {lookup:'List description for 012abcde'}
                        var idList = $scope[suffixCleanId(schemaEntry, "_ids")];
                        var thisConversion = void 0;
                        if (fieldValue && idList && idList.length > 0) {
                            if (fieldName.indexOf(".") !== -1) {
                                throw new Error("Trying to directly assign to a nested field 332");
                            } // Not sure that this can happen, but put in a runtime test
                            if (
                            /*
                             Check we are starting with an ObjectId (ie not being called because of $watch on conversion, with a
                             converted value, which would cause an exception)
                             */
                            fieldValue.toString().match(/^[a-f0-9]{24}$/) &&
                                /*
                                  We are not suppressing conversions
                                 */
                                (!schemaEntry.internalRef || !schemaEntry.internalRef.noConvert)) {
                                anObject[fieldName] = convertForeignKeys(schemaEntry, fieldValue, $scope[suffixCleanId(schemaEntry, "Options")], idList);
                            }
                        }
                        else if (schemaEntry.select2) {
                            // Do nothing with these - handled elsewhere (and deprecated)
                            console.log("fng-select2 is deprecated - use fng-ui-select instead");
                            void (schemaEntry.select2);
                        }
                        else if (fieldValue && (thisConversion = getConversionObject($scope, fieldName, schemaName)) &&
                            thisConversion.fngajax &&
                            !thisConversion.noconvert) {
                            thisConversion.fngajax(fieldValue, schemaEntry, function (updateEntry, value) {
                                // Update the master and (preserving pristine if appropriate) the record
                                setData(master, updateEntry.name, offset, value);
                                preservePristine(angular.element("#" + updateEntry.id), function () {
                                    setData($scope.record, updateEntry.name, offset, value);
                                });
                            });
                        }
                    }
                }
                return anObject;
            };
            // Convert foreign keys into their display for selects
            // Called when the model is read and when the lookups are read
            // No support for nested schemas here as it is called from convertToAngularModel which does that
            function convertForeignKeys(schemaElement, input, values, ids) {
                if (schemaElement.array || angular.isArray(input)) {
                    var returnArray = [];
                    var needsX = schemaElement.array && (!schemaElement.directive || simpleArrayNeedsX(schemaElement));
                    for (var j = 0; j < input.length; j++) {
                        var val = input[j];
                        if (val && val.x) {
                            val = val.x;
                        }
                        var lookup = convertIdToListValue(val, ids, values, schemaElement.name);
                        if (needsX) {
                            lookup = { x: lookup };
                        }
                        returnArray.push(lookup);
                    }
                    return returnArray;
                }
                else if (schemaElement.select2) {
                    return { id: input, text: convertIdToListValue(input, ids, values, schemaElement.name) };
                }
                else {
                    return convertIdToListValue(input, ids, values, schemaElement.name);
                }
            }
            // Convert ids into their foreign keys
            // Called when saving the model
            // No support for nested schemas here as it is called from convertToMongoModel which does that
            function convertToForeignKeys(schemaElement, input, values, ids) {
                if (schemaElement.array) {
                    var returnArray = [];
                    for (var j = 0; j < input.length; j++) {
                        returnArray.push(convertListValueToId(input[j], values, ids, schemaElement.name));
                    }
                    return returnArray;
                }
                else {
                    return convertListValueToId(input, values, ids, schemaElement.name);
                }
            }
            var convertListValueToId = function (value, valuesArray, idsArray, fname) {
                var textToConvert = _.isObject(value) ? (value.x || value.text) : value;
                if (textToConvert && textToConvert.match(/^[0-9a-f]{24}$/)) {
                    return textToConvert; // a plugin probably added this
                }
                else {
                    var index = valuesArray.indexOf(textToConvert);
                    if (index === -1) {
                        throw new Error("convertListValueToId: Invalid data - value " + textToConvert + " not found in " + valuesArray + " processing " + fname);
                    }
                    return idsArray[index];
                }
            };
            var preservePristine = function preservePristine(element, fn) {
                // stop the form being set to dirty when a fn is called
                // Use when the record (and master) need to be updated by lookup values displayed asynchronously
                var modelController = element.inheritedData("$ngModelController");
                var isClean = (modelController && modelController.$pristine);
                if (isClean) {
                    // fake it to dirty here and reset after call to fn
                    modelController.$pristine = false;
                }
                fn();
                if (isClean) {
                    modelController.$pristine = true;
                }
            };
            var convertIdToListValue = function convertIdToListValue(id, idsArray, valuesArray, fname) {
                if (typeof (id) === "object") {
                    id = id.id;
                }
                var index = idsArray.indexOf(id);
                if (index === -1) {
                    index = valuesArray.indexOf(id); // This can get called twice - second time with converted value (not sure how atm) so protect against that...
                    if (index === -1) {
                        throw new Error("convertIdToListValue: Invalid data - id " + id + " not found in " + idsArray + " processing " + fname);
                    }
                }
                return valuesArray[index];
            };
            var processServerData = function processServerData(recordFromServer, $scope, ctrlState) {
                ctrlState.master = convertToAngularModel($scope.formSchema, recordFromServer, 0, $scope);
                $scope.phase = "ready";
                $scope.cancel();
            };
            function convertOldToNew(ref, val, attrib, newVals, oldVals) {
                // check this is a change to an existing value, rather than a new one or one being deleted
                if (oldVals && oldVals.length > 0 && oldVals.length === newVals.length && val[attrib]) {
                    var index = oldVals.findIndex(function (a) { return a[ref.value] === val[attrib]; });
                    if (index > -1) {
                        var newVal = newVals[index][ref.value];
                        if (newVal) {
                            val[attrib] = newVal;
                        }
                    }
                }
            }
            function fillFormFromBackendCustomSchema(schema, $scope, formGeneratorInstance, recordHandlerInstance, ctrlState) {
                var listOnly = (!$scope.id && !$scope.newRecord);
                // passing null for formSchema parameter prevents all the work being done when we are just after the list data,
                // but should be removed when/if formschemas are cached
                formGeneratorInstance.handleSchema("Main " + $scope.modelName, schema, listOnly ? null : $scope.formSchema, $scope.listSchema, "", true, $scope, ctrlState);
                function processLookupHandlers(newValue, oldValue) {
                    // If we have any internal lookups then update the references
                    $scope.internalLookups.forEach(function (lkp) {
                        var newVal = newValue[lkp.ref.property];
                        var oldVal = oldValue[lkp.ref.property];
                        setUpInternalLookupLists($scope, lkp.lookupOptions, lkp.lookupIds, newVal, lkp.ref.value);
                        // now change the looked-up values that matched the old to the new
                        if ((newVal && newVal.length > 0) || (oldVal && oldVal.length > 0)) {
                            lkp.handlers.forEach(function (h) {
                                if (h.possibleArray) {
                                    var arr = getData($scope.record, h.possibleArray, null);
                                    if (arr && arr.length > 0) {
                                        arr.forEach(function (a) { return convertOldToNew(lkp.ref, a, h.lastPart, newVal, oldVal); });
                                    }
                                }
                                else if (angular.isArray($scope.record[h.lastPart])) {
                                    $scope.record[h.lastPart].forEach(function (a) {
                                        convertOldToNew(lkp.ref, a, "x", newVal, oldVal);
                                    });
                                }
                                else {
                                    convertOldToNew(lkp.ref, $scope.record, h.lastPart, newVal, oldVal);
                                }
                            });
                        }
                    });
                    // If we have any list lookups then update the references
                    $scope.listLookups.forEach(function (lkp) {
                        function extractIdVal(obj, idString) {
                            var retVal = obj[idString];
                            if (retVal && retVal.id) {
                                retVal = retVal.id;
                            }
                            return retVal;
                        }
                        function blankListLookup(inst) {
                            setData($scope.record, inst.name);
                        }
                        var idString = lkp.ref.id.slice(1);
                        if (idString.includes(".")) {
                            throw new Error("No support for nested list lookups yet - ".concat(JSON.stringify(lkp.ref)));
                        }
                        var newVal = extractIdVal(newValue, idString);
                        var oldVal = extractIdVal(oldValue, idString);
                        if (newVal !== oldVal) {
                            if (newVal) {
                                if (oldVal) {
                                    lkp.handlers.forEach(function (h) {
                                        h.oldValue = getData($scope.record, h.formInstructions.name);
                                        if (angular.isArray(h.oldValue)) {
                                            h.oldId = h.oldValue.map(function (a) {
                                                return $scope[h.formInstructions.ids][$scope[h.formInstructions.options].indexOf(a)];
                                            });
                                        }
                                        else {
                                            h.oldId = $scope[h.formInstructions.ids][$scope[h.formInstructions.options].indexOf(h.oldValue)];
                                        }
                                    });
                                }
                                SubmissionsService.readRecord(lkp.ref.collection, newVal).then(function (response) {
                                    lkp.handlers.forEach(function (h) {
                                        var optionsList = $scope[h.formInstructions.options];
                                        optionsList.length = 0;
                                        var idList = $scope[h.formInstructions.ids];
                                        idList.length = 0;
                                        var data = response.data[lkp.ref.property] || [];
                                        for (var i = 0; i < data.length; i++) {
                                            var option = data[i][lkp.ref.value];
                                            var pos = _.sortedIndex(optionsList, option);
                                            // handle dupes
                                            if (optionsList[pos] === option) {
                                                option = option + "    (" + data[i]._id + ")";
                                                pos = _.sortedIndex(optionsList, option);
                                            }
                                            optionsList.splice(pos, 0, option);
                                            idList.splice(pos, 0, data[i]._id);
                                        }
                                        if (Object.keys(oldValue).length === 0) {
                                            // Not sure how safe this is, but the record is fresh so I think it's OK...
                                            updateRecordWithLookupValues(h.formInstructions, $scope, ctrlState, true);
                                        }
                                        else if (h.oldId) {
                                            // Here we are reacting to a change in the lookup pointer in the record.
                                            // If the old id exists in the new idList we can keep it, otherwise we need to blank it.
                                            // We need to remember that we can have an array of ids
                                            if (angular.isArray(h.oldId)) {
                                                h.oldId.forEach(function (id, idx) {
                                                    var pos = idList.indexOf(id);
                                                    setData($scope.record, h.formInstructions.name, idx, pos === -1 ? undefined : optionsList[pos]);
                                                });
                                            }
                                            else {
                                                var pos_1 = idList.indexOf(h.oldId);
                                                if (pos_1 !== -1) {
                                                    setData($scope.record, h.formInstructions.name, undefined, optionsList[pos_1]);
                                                }
                                                else {
                                                    blankListLookup(h.formInstructions);
                                                }
                                            }
                                        }
                                        else {
                                            blankListLookup(h.formInstructions);
                                        }
                                    });
                                });
                            }
                            else {
                                lkp.handlers.forEach(function (h) {
                                    $scope[h.formInstructions.options].length = 0;
                                    $scope[h.formInstructions.ids].length = 0;
                                    blankListLookup(h.formInstructions);
                                });
                            }
                        }
                    });
                }
                function notifyReady() {
                    $scope.phase = "ready";
                    $scope.cancel();
                    processLookupHandlers($scope.record, {});
                }
                if (listOnly) {
                    ctrlState.allowLocationChange = true;
                }
                else {
                    var force = true;
                    if (!$scope.newRecord) {
                        $scope.dropConversionWatcher = $scope.$watchCollection("conversions", function (newValue, oldValue) {
                            if (newValue !== oldValue && $scope.originalData) {
                                processServerData($scope.originalData, $scope, ctrlState);
                            }
                        });
                    }
                    $scope.$watch("record", function (newValue, oldValue) {
                        if (newValue !== oldValue) {
                            if (Object.keys(oldValue).length > 0 && $scope.dropConversionWatcher) {
                                $scope.dropConversionWatcher(); // Don't want to convert changed data
                                $scope.dropConversionWatcher = null;
                            }
                            force = formGeneratorInstance.updateDataDependentDisplay(newValue, oldValue, force, $scope);
                            processLookupHandlers(newValue, oldValue);
                            if (fng.formsAngular.title) {
                                var title = fng.formsAngular.title.prefix || '';
                                if ($scope['editFormHeader']) {
                                    title += $scope['editFormHeader']();
                                }
                                else {
                                    for (var listElm in $scope.listSchema) {
                                        if ($scope.listSchema.hasOwnProperty(listElm)) {
                                            title += $scope.getListData($scope.record, $scope.listSchema[listElm].name) + ' ';
                                        }
                                    }
                                }
                                title = title.trimEnd() + (fng.formsAngular.title.suffix || '');
                                $window.document.title = title;
                            }
                        }
                    }, true);
                    if ($scope.id) {
                        // Going to read a record
                        if (typeof $scope.dataEventFunctions.onBeforeRead === "function") {
                            $scope.dataEventFunctions.onBeforeRead($scope.id, function (err) {
                                if (err) {
                                    $scope.showError(err);
                                }
                                else {
                                    recordHandlerInstance.readRecord($scope, ctrlState);
                                }
                            });
                        }
                        else {
                            recordHandlerInstance.readRecord($scope, ctrlState);
                        }
                    }
                    else {
                        // New record
                        ctrlState.allowLocationChange = false;
                        ctrlState.master = $scope.setDefaults($scope.formSchema);
                        var passedRecord = $scope.initialiseNewRecord || $location.$$search.r;
                        if (passedRecord) {
                            try {
                                Object.assign(ctrlState.master, JSON.parse(passedRecord));
                                if (!$scope["newRecordsStartPristine"]) {
                                    // Although this is a new record we are making it dirty from the url so we need to $setDirty
                                    $scope.$on("fngCancel", function () {
                                        $timeout(function () {
                                            if ($scope[$scope.topLevelFormName]) {
                                                $scope[$scope.topLevelFormName].$setDirty();
                                            }
                                        }, 1000); // Has to fire after the setPristime timeout.
                                    });
                                }
                            }
                            catch (e) {
                                console.log("Error parsing specified record : " + e.message);
                            }
                        }
                        if (typeof $scope.dataEventFunctions.onInitialiseNewRecord === "function") {
                            console.log("onInitialiseNewRecord is deprecated - use the async version - onNewRecordInit(data,cb)");
                            $scope.dataEventFunctions.onInitialiseNewRecord(ctrlState.master);
                        }
                        if (typeof $scope.dataEventFunctions.onNewRecordInit === "function") {
                            $scope.dataEventFunctions.onNewRecordInit(ctrlState.master, function (err) {
                                if (err) {
                                    $scope.showError(err);
                                }
                                else {
                                    notifyReady();
                                }
                            });
                        }
                        else {
                            notifyReady();
                        }
                    }
                }
            }
            function handleError($scope) {
                return function (response) {
                    if ([200, 400].indexOf(response.status) !== -1) {
                        var errorMessage = "";
                        if (response.data && response.data.errors) {
                            for (var errorField in response.data.errors) {
                                if (response.data.errors.hasOwnProperty(errorField)) {
                                    errorMessage += "<li><b>" + $filter("titleCase")(errorField) + ": </b> ";
                                    switch (response.data.errors[errorField].type) {
                                        case "enum":
                                            errorMessage += "You need to select from the list of values";
                                            break;
                                        default:
                                            errorMessage += response.data.errors[errorField].message;
                                            break;
                                    }
                                    errorMessage += "</li>";
                                }
                            }
                        }
                        if (errorMessage.length > 0) {
                            errorMessage = (response.data.message || response.data._message) + "<br /><ul>" + errorMessage + "</ul>";
                        }
                        else {
                            errorMessage = response.data.message || response.data._message || response.data.err || "Error!  Sorry - No further details available.";
                        }
                        $scope.showError(errorMessage);
                    }
                    else {
                        $scope.showError(response.status + " " + JSON.stringify(response.data));
                    }
                };
            }
            function handleIncomingData(data, $scope, ctrlState) {
                ctrlState.allowLocationChange = false;
                $scope.phase = "reading";
                if (typeof $scope.dataEventFunctions.onAfterRead === "function") {
                    $scope.dataEventFunctions.onAfterRead(data);
                }
                $scope.originalData = data;
                processServerData(data, $scope, ctrlState);
            }
            function addArrayLookupToLookupList($scope, formInstructions, ref, lookups) {
                var nameElements = formInstructions.name.split(".");
                var refHandler = lookups.find(function (lkp) {
                    return lkp.ref.property === ref.property && lkp.ref.value === ref.value;
                });
                var thisHandler = {
                    formInstructions: formInstructions,
                    lastPart: nameElements.pop(),
                    possibleArray: nameElements.join(".")
                };
                if (!refHandler) {
                    refHandler = {
                        ref: ref,
                        lookupOptions: [],
                        lookupIds: [],
                        handlers: []
                    };
                    lookups.push(refHandler);
                }
                refHandler.handlers.push(thisHandler);
                $scope[formInstructions.options] = refHandler.lookupOptions;
                $scope[formInstructions.ids] = refHandler.lookupIds;
            }
            return {
                readRecord: function readRecord($scope, ctrlState) {
                    $scope.readingRecord = SubmissionsService.readRecord($scope.modelName, $scope.id);
                    $scope.readingRecord
                        .then(function (response) {
                        var data = angular.copy(response.data);
                        handleIncomingData(data, $scope, ctrlState);
                    }, function (error) {
                        if (error.status === 404) {
                            $location.path("/404");
                        }
                        else {
                            $scope.handleHttpError(error);
                        }
                    });
                },
                scrollTheList: function scrollTheList($scope) {
                    var pagesLoaded = $scope.pagesLoaded;
                    SubmissionsService.getPagedAndFilteredList($scope.modelName, {
                        aggregate: $location.$$search.a,
                        find: $location.$$search.f,
                        limit: $scope.pageSize,
                        skip: pagesLoaded * $scope.pageSize,
                        order: $location.$$search.o
                    })
                        .then(function (response) {
                        var data = response.data;
                        if (angular.isArray(data)) {
                            //  I have seen an intermittent problem where a page is requested twice
                            if (pagesLoaded === $scope.pagesLoaded) {
                                $scope.pagesLoaded++;
                                $scope.recordList = $scope.recordList.concat(data);
                            }
                            else {
                                console.log("DEBUG: infinite scroll component asked for a page twice - the model was " + $scope.modelName);
                            }
                        }
                        else {
                            $scope.showError(data, "Invalid query");
                        }
                    }, $scope.handleHttpError);
                },
                deleteRecord: function deleteRecord(id, $scope, ctrlState) {
                    $scope.phase = "deleting";
                    SubmissionsService.deleteRecord($scope.modelName, id)
                        .then(function () {
                        if (typeof $scope.dataEventFunctions.onAfterDelete === "function") {
                            $scope.dataEventFunctions.onAfterDelete(ctrlState.master);
                        }
                        routingService.redirectTo()("onDelete", $scope, $location);
                    }, function (err) {
                        if (err.status === 404) {
                            // Someone already deleted it
                            routingService.redirectTo()("onDelete", $scope, $location);
                        }
                        else {
                            $scope.showError("".concat(err.statusText, " (").concat(err.status, ") while deleting record<br />").concat(err.data), 'Error deleting record');
                        }
                    });
                },
                updateDocument: function updateDocument(dataToSave, options, $scope, ctrlState) {
                    $scope.phase = "updating";
                    SubmissionsService.updateRecord($scope.modelName, $scope.id, dataToSave)
                        .then(function (response) {
                        var data = response.data;
                        if (data.success !== false) {
                            if (typeof $scope.dataEventFunctions.onAfterUpdate === "function") {
                                $scope.dataEventFunctions.onAfterUpdate(data, ctrlState.master);
                            }
                            if (options.redirect) {
                                if (options.allowChange) {
                                    ctrlState.allowLocationChange = true;
                                }
                                $window.location = options.redirect;
                            }
                            else {
                                handleIncomingData(data, $scope, ctrlState);
                                $scope.setPristine(false);
                            }
                        }
                        else {
                            $scope.showError(data);
                            $scope.phase = "ready";
                        }
                    }, function (err) {
                        $scope.handleHttpError(err);
                        $scope.phase = "ready";
                    });
                },
                createNew: function createNew(dataToSave, options, $scope, ctrlState) {
                    SubmissionsService.createRecord($scope.modelName, dataToSave)
                        .then(function (response) {
                        var data = response.data;
                        if (data.success !== false) {
                            ctrlState.allowLocationChange = true;
                            if (typeof $scope.dataEventFunctions.onAfterCreate === "function") {
                                $scope.dataEventFunctions.onAfterCreate(data);
                            }
                            if (options.redirect) {
                                $window.location = options.redirect;
                            }
                            else {
                                routingService.redirectTo()("edit", $scope, $location, data._id);
                            }
                        }
                        else {
                            $scope.showError(data);
                        }
                    }, $scope.handleHttpError);
                },
                getListData: getListData,
                suffixCleanId: suffixCleanId,
                setData: setData,
                setUpLookupOptions: function setUpLookupOptions(lookupCollection, schemaElement, $scope, ctrlState, handleSchema) {
                    var optionsList = $scope[schemaElement.options] = [];
                    var idList = $scope[schemaElement.ids] = [];
                    SchemasService.getSchema(lookupCollection)
                        .then(function (response) {
                        var data = response.data;
                        var listInstructions = [];
                        handleSchema("Lookup " + lookupCollection, data, null, listInstructions, "", false, $scope, ctrlState);
                        var dataRequest;
                        if (typeof schemaElement.filter !== "undefined" && schemaElement.filter) {
                            dataRequest = SubmissionsService.getPagedAndFilteredList(lookupCollection, schemaElement.filter);
                        }
                        else {
                            dataRequest = SubmissionsService.getAll(lookupCollection);
                        }
                        dataRequest
                            .then(function (response) {
                            var data = angular.copy(response.data);
                            if (data) {
                                for (var i = 0; i < data.length; i++) {
                                    var option = "";
                                    for (var j = 0; j < listInstructions.length; j++) {
                                        var thisVal = data[i][listInstructions[j].name];
                                        option += thisVal ? thisVal + " " : "";
                                    }
                                    option = option.trim();
                                    var pos = _.sortedIndex(optionsList, option);
                                    // handle dupes (ideally people will use unique indexes to stop them but...)
                                    if (optionsList[pos] === option) {
                                        option = option + "    (" + data[i]._id + ")";
                                        pos = _.sortedIndex(optionsList, option);
                                    }
                                    optionsList.splice(pos, 0, option);
                                    idList.splice(pos, 0, data[i]._id);
                                }
                                if ($scope.readingRecord) {
                                    $scope.readingRecord
                                        .then(function () {
                                        updateRecordWithLookupValues(schemaElement, $scope, ctrlState);
                                    });
                                }
                            }
                        });
                    });
                },
                setUpLookupListOptions: function setUpLookupListOptions(ref, formInstructions, $scope, ctrlState) {
                    var optionsList = $scope[formInstructions.options] = [];
                    var idList = $scope[formInstructions.ids] = [];
                    if (ref.id[0] === "$") {
                        // id of document that contains out lookup list comes from record, so we need to deal with in $watch by adding it to listLookups
                        addArrayLookupToLookupList($scope, formInstructions, ref, $scope.listLookups);
                    }
                    else {
                        // we can do it now
                        SubmissionsService.readRecord(ref.collection, $scope.$eval(ref.id)).then(function (response) {
                            var data = response.data[ref.property];
                            for (var i = 0; i < data.length; i++) {
                                var option = data[i][ref.value];
                                var pos = _.sortedIndex(optionsList, option);
                                // handle dupes
                                if (optionsList[pos] === option) {
                                    option = option + "    (" + data[i]._id + ")";
                                    pos = _.sortedIndex(optionsList, option);
                                }
                                optionsList.splice(pos, 0, option);
                                idList.splice(pos, 0, data[i]._id);
                            }
                            updateRecordWithLookupValues(formInstructions, $scope, ctrlState);
                        });
                    }
                },
                handleInternalLookup: function handleInternalLookup($scope, formInstructions, ref) {
                    addArrayLookupToLookupList($scope, formInstructions, ref, $scope.internalLookups);
                },
                preservePristine: preservePristine,
                // Reverse the process of convertToAngularModel
                convertToMongoModel: function convertToMongoModel(schema, anObject, prefixLength, $scope, schemaName) {
                    function convertLookup(lookup, conversionInst) {
                        var retVal;
                        if (conversionInst && conversionInst.fngajax) {
                            if (lookup) {
                                retVal = lookup.id || lookup;
                            }
                        }
                        else if (lookup) {
                            retVal = lookup.text || (lookup.x ? lookup.x.text : lookup);
                        }
                        return retVal;
                    }
                    var _loop_1 = function () {
                        var schemaI = schema[i];
                        var fieldname = schemaI.name.slice(prefixLength);
                        var thisField = getListData(anObject, fieldname, null, $scope);
                        if (schemaI.schema) {
                            if (thisField) {
                                for (var j = 0; j < thisField.length; j++) {
                                    thisField[j] = convertToMongoModel(schemaI.schema, thisField[j], 1 + fieldname.length, $scope, fieldname);
                                }
                            }
                        }
                        else {
                            // Convert {array:[{x:'item 1'}]} to {array:['item 1']}
                            if (schemaI.array && simpleArrayNeedsX(schemaI) && thisField) {
                                for (var k = 0; k < thisField.length; k++) {
                                    thisField[k] = thisField[k].x;
                                }
                            }
                            // Convert {lookup:'List description for 012abcde'} to {lookup:'012abcde'}
                            var idList_1 = $scope[suffixCleanId(schemaI, "_ids")];
                            if (idList_1 && idList_1.length > 0) {
                                updateObject(fieldname, anObject, function (value) {
                                    return convertToForeignKeys(schemaI, value, $scope[suffixCleanId(schemaI, "Options")], idList_1);
                                });
                            }
                            else {
                                var thisConversion = getConversionObject($scope, fieldname, schemaName);
                                if (thisConversion) {
                                    var lookup = getData(anObject, fieldname, null);
                                    var newVal = void 0;
                                    if (schemaI.array) {
                                        newVal = [];
                                        if (lookup) {
                                            for (var n = 0; n < lookup.length; n++) {
                                                newVal[n] = convertLookup(lookup[n], thisConversion);
                                            }
                                        }
                                    }
                                    else {
                                        newVal = convertLookup(lookup, thisConversion);
                                    }
                                    setData(anObject, fieldname, null, newVal);
                                }
                            }
                        }
                    };
                    for (var i = 0; i < schema.length; i++) {
                        _loop_1();
                    }
                    return anObject;
                },
                convertIdToListValue: convertIdToListValue,
                handleError: handleError,
                decorateScope: function decorateScope($scope, $uibModal, recordHandlerInstance, ctrlState) {
                    $scope.handleHttpError = handleError($scope);
                    $scope.cancel = function () {
                        angular.copy(ctrlState.master, $scope.record);
                        $scope.$broadcast("fngCancel", $scope);
                        // Let call backs etc resolve in case they dirty form, then clean it
                        $timeout($scope.setPristine);
                    };
                    //listener for any child scopes to display messages
                    // pass like this:
                    //    scope.$emit('showErrorMessage', {title: 'Your error Title', body: 'The body of the error message'});
                    // or
                    //    scope.$broadcast('showErrorMessage', {title: 'Your error Title', body: 'The body of the error message'});
                    $scope.$on("showErrorMessage", function (event, args) {
                        if (!event.defaultPrevented) {
                            event.defaultPrevented = true;
                            $scope.showError(args.body, args.title);
                        }
                    });
                    $scope.showError = function (error, alertTitle) {
                        $scope.alertTitle = alertTitle ? alertTitle : "Error!";
                        if (typeof error === "string") {
                            $scope.errorMessage = error;
                        }
                        else if (!error) {
                            $scope.errorMessage = "An error occurred - that's all we got.  Sorry.";
                        }
                        else if (error.message && typeof error.message === "string") {
                            $scope.errorMessage = error.message;
                        }
                        else if (error.data && error.data.message) {
                            $scope.errorMessage = error.data.message;
                        }
                        else {
                            try {
                                $scope.errorMessage = JSON.stringify(error);
                            }
                            catch (e) {
                                $scope.errorMessage = error;
                            }
                        }
                        $scope.errorHideTimer = window.setTimeout(function () {
                            $scope.dismissError();
                            $scope.$digest();
                        }, 3500 + (1000 * ($scope.alertTitle + $scope.errorMessage).length / 50));
                        $scope.errorVisible = true;
                        window.setTimeout(function () {
                            $scope.$digest();
                        });
                    };
                    $scope.clearTimeout = function () {
                        if ($scope.errorHideTimer) {
                            clearTimeout($scope.errorHideTimer);
                            delete $scope.errorHideTimer;
                        }
                    };
                    $scope.dismissError = function () {
                        $scope.clearTimeout;
                        $scope.errorVisible = false;
                        delete $scope.errorMessage;
                        delete $scope.alertTitle;
                    };
                    $scope.stickError = function () {
                        clearTimeout($scope.errorHideTimer);
                    };
                    $scope.prepareForSave = function (cb) {
                        //Convert the lookup values into ids
                        var dataToSave = recordHandlerInstance.convertToMongoModel($scope.formSchema, angular.copy($scope.record), 0, $scope);
                        if ($scope.id) {
                            if (typeof $scope.dataEventFunctions.onBeforeUpdate === "function") {
                                $scope.dataEventFunctions.onBeforeUpdate(dataToSave, ctrlState.master, function (err) {
                                    if (err) {
                                        cb(err);
                                    }
                                    else {
                                        cb(null, dataToSave);
                                    }
                                });
                            }
                            else {
                                cb(null, dataToSave);
                            }
                        }
                        else {
                            if (typeof $scope.dataEventFunctions.onBeforeCreate === "function") {
                                $scope.dataEventFunctions.onBeforeCreate(dataToSave, function (err) {
                                    if (err) {
                                        cb(err);
                                    }
                                    else {
                                        cb(null, dataToSave);
                                    }
                                });
                            }
                            else {
                                cb(null, dataToSave);
                            }
                        }
                    };
                    $scope.save = function (options) {
                        options = options || {};
                        $scope.prepareForSave(function (err, dataToSave) {
                            if (err) {
                                if (err !== "_update_handled_") {
                                    $timeout(function () {
                                        $scope.showError(err);
                                    });
                                }
                            }
                            else if ($scope.id) {
                                recordHandlerInstance.updateDocument(dataToSave, options, $scope, ctrlState);
                            }
                            else {
                                recordHandlerInstance.createNew(dataToSave, options, $scope, ctrlState);
                            }
                        });
                    };
                    $scope.newClick = function () {
                        routingService.redirectTo()("new", $scope, $location);
                    };
                    $scope.$on("$locationChangeStart", function (event, next) {
                        // let changed = !$scope.isCancelDisabled();
                        // let curPath = window.location.href.split('/');
                        // let nextPath = next.split('/');
                        // let tabChangeOnly = true;
                        // let i = 0;
                        // do {
                        //   i += 1;
                        //   if (curPath[i] !== nextPath[i]) {
                        //     tabChangeOnly = false;
                        //   }
                        // } while (tabChangeOnly && curPath[i] !== 'edit');
                        // if (tabChangeOnly) {
                        //   // let dataToReturn = recordHandlerInstance.convertToMongoModel($scope.formSchema, angular.copy($scope.record), 0, $scope);
                        //   SubmissionsService.setUpForTabChange($scope.modelName, $scope.id, $scope.record, ctrlState.master, changed);
                        // } else if (!ctrlState.allowLocationChange && changed) {
                        if (!ctrlState.allowLocationChange && !$scope.isCancelDisabled()) {
                            event.preventDefault();
                            var modalInstance = $uibModal.open({
                                template: "<div class=\"modal-header\">\n   <h3>Record modified</h3>\n</div>\n<div class=\"modal-body\">\n   <p>Would you like to save your changes?</p>\n</div>\n<div class=\"modal-footer\">\n    <button class=\"btn btn-primary dlg-yes\" ng-click=\"yes()\">Yes</button>\n    <button class=\"btn btn-warning dlg-no\" ng-click=\"no()\">No</button>\n    <button class=\"btn dlg-cancel\" ng-click=\"cancel()\">Cancel</button>\n</div>",
                                controller: "SaveChangesModalCtrl",
                                backdrop: "static"
                            });
                            modalInstance.result
                                .then(function (result) {
                                if (result) {
                                    $scope.save({ redirect: next, allowChange: true }); // save changes
                                }
                                else {
                                    ctrlState.allowLocationChange = true;
                                    $window.location = next;
                                }
                            })
                                .catch(_handleCancel);
                        }
                    });
                    $scope.deleteClick = function () {
                        if ($scope.record._id) {
                            var confirmDelete = void 0;
                            if ($scope.unconfirmedDelete) {
                                confirmDelete = Promise.resolve(true);
                            }
                            else {
                                var modalInstance = $uibModal.open({
                                    template: "<div class=\"modal-header\">\n   <h3>Delete Item</h3>\n</div>\n<div class=\"modal-body\">\n   <p>Are you sure you want to delete this record?</p>\n</div>\n<div class=\"modal-footer\">\n    <button class=\"btn btn-primary dlg-no\" ng-click=\"cancel()\">No</button>\n    <button class=\"btn btn-warning dlg-yes\" ng-click=\"yes()\">Yes</button>\n</div>",
                                    controller: "SaveChangesModalCtrl",
                                    backdrop: "static"
                                });
                                confirmDelete = modalInstance.result;
                            }
                            confirmDelete.then(function (result) {
                                function doTheDeletion() {
                                    recordHandlerInstance.deleteRecord($scope.id, $scope, ctrlState);
                                }
                                if (result) {
                                    if (typeof $scope.dataEventFunctions.onBeforeDelete === "function") {
                                        $scope.dataEventFunctions.onBeforeDelete(ctrlState.master, function (err) {
                                            if (err) {
                                                if (err !== "_delete_handled_") {
                                                    $scope.showError(err);
                                                }
                                            }
                                            else {
                                                doTheDeletion();
                                            }
                                        });
                                    }
                                    else {
                                        doTheDeletion();
                                    }
                                }
                            })
                                .catch(_handleCancel);
                        }
                    };
                    $scope.isCancelDisabled = function () {
                        if (($scope[$scope.topLevelFormName] && $scope[$scope.topLevelFormName].$pristine) || $scope.phase !== "ready") {
                            return true;
                        }
                        else if (typeof $scope.disableFunctions.isCancelDisabled === "function") {
                            return $scope.disableFunctions.isCancelDisabled($scope.record, ctrlState.master, $scope[$scope.topLevelFormName]);
                        }
                        else {
                            return false;
                        }
                    };
                    $scope.isSaveDisabled = function () {
                        $scope.whyDisabled = undefined;
                        var pristine = false;
                        function generateWhyDisabledMessage(form, subFormName) {
                            form.$$controls.forEach(function (c) {
                                if (c.$invalid) {
                                    if (c.$$controls) {
                                        // nested form
                                        generateWhyDisabledMessage(c, c.$name);
                                    }
                                    else {
                                        $scope.whyDisabled += "<br /><strong>";
                                        if (subFormName) {
                                            $scope.whyDisabled += subFormName + ' ';
                                        }
                                        if (cssFrameworkService.framework() === "bs2" &&
                                            c.$$element &&
                                            c.$$element.parent() &&
                                            c.$$element.parent().parent() &&
                                            c.$$element.parent().parent().find("label") &&
                                            c.$$element.parent().parent().find("label").text()) {
                                            $scope.whyDisabled += c.$$element.parent().parent().find("label").text();
                                        }
                                        else if (cssFrameworkService.framework() === "bs3" &&
                                            c.$$element &&
                                            c.$$element.parent() &&
                                            c.$$element.parent().parent() &&
                                            c.$$element.parent().parent().parent() &&
                                            c.$$element.parent().parent().parent().find("label") &&
                                            c.$$element.parent().parent().parent().find("label").text()) {
                                            $scope.whyDisabled += c.$$element.parent().parent().parent().find("label").text();
                                        }
                                        else {
                                            $scope.whyDisabled += c.$name;
                                        }
                                        $scope.whyDisabled += "</strong>: ";
                                        if (c.$error) {
                                            for (var type in c.$error) {
                                                if (c.$error.hasOwnProperty(type)) {
                                                    switch (type) {
                                                        case "required":
                                                            $scope.whyDisabled += "Field missing required value. ";
                                                            break;
                                                        case "pattern":
                                                            $scope.whyDisabled += "Field does not match required pattern. ";
                                                            break;
                                                        default:
                                                            $scope.whyDisabled += type + ". ";
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            });
                        }
                        if ($scope[$scope.topLevelFormName]) {
                            if ($scope[$scope.topLevelFormName].$invalid) {
                                $scope.whyDisabled = 'The form data is invalid:';
                                generateWhyDisabledMessage($scope[$scope.topLevelFormName]);
                            }
                            else if ($scope[$scope.topLevelFormName].$pristine) {
                                // Don't have disabled message - should be obvious from Cancel being disabled,
                                // and the message comes up when the Save button is clicked.
                                pristine = true;
                            }
                        }
                        else {
                            $scope.whyDisabled = "Top level form name invalid";
                        }
                        if (pristine || !!$scope.whyDisabled || $scope.phase !== "ready") {
                            return true;
                        }
                        else if (typeof $scope.disableFunctions.isSaveDisabled !== "function") {
                            return false;
                        }
                        else {
                            var retVal = $scope.disableFunctions.isSaveDisabled($scope.record, ctrlState.master, $scope[$scope.topLevelFormName]);
                            if (typeof retVal === "string") {
                                $scope.whyDisabled = retVal;
                            }
                            else {
                                $scope.whyDisabled = "An application level user-specified function is inhibiting saving the record";
                            }
                            return !!retVal;
                        }
                    };
                    $scope.isDeleteDisabled = function () {
                        if (!$scope.id || $scope.phase !== "ready") {
                            return true;
                        }
                        else if (typeof $scope.disableFunctions.isDeleteDisabled === "function") {
                            return $scope.disableFunctions.isDeleteDisabled($scope.record, ctrlState.master, $scope[$scope.topLevelFormName]);
                        }
                        else {
                            return false;
                        }
                    };
                    $scope.isNewDisabled = function () {
                        if (typeof $scope.disableFunctions.isNewDisabled === "function") {
                            return $scope.disableFunctions.isNewDisabled($scope.record, ctrlState.master, $scope[$scope.topLevelFormName]);
                        }
                        else {
                            return false;
                        }
                    };
                    $scope.setDefaults = function (formSchema, base) {
                        if (base === void 0) { base = ''; }
                        var retVal = {};
                        formSchema.forEach(function (s) {
                            if (s.defaultValue !== undefined) {
                                var nameParts = s.name.replace(base, '').split(".");
                                var target = retVal;
                                for (var i = 0; i < nameParts.length - 1; i++) {
                                    if (!target[nameParts[i]]) {
                                        target[nameParts[i]] = {};
                                    }
                                    target = target[nameParts[i]];
                                }
                                target[nameParts[nameParts.length - 1]] = s.defaultValue;
                            }
                        });
                        return retVal;
                    };
                    $scope.getVal = function (expression, index) {
                        if (expression.indexOf("$index") === -1 || typeof index !== "undefined") {
                            expression = expression.replace(/\$index/g, index);
                            return $scope.$eval("record." + expression);
                        }
                        //else {
                        // Used to show error here, but angular seems to call before record is populated sometimes
                        //      throw new Error('Invalid expression in getVal(): ' + expression);
                        //}
                    };
                    $scope.sortableOptions = {
                        update: function () {
                            if ($scope.topLevelFormName) {
                                $scope[$scope.topLevelFormName].$setDirty();
                            }
                        }
                    };
                    $scope.setUpCustomLookupOptions = function (schemaElement, ids, options, baseScope) {
                        for (var _i = 0, _a = [$scope, baseScope]; _i < _a.length; _i++) {
                            var scope = _a[_i];
                            if (scope) {
                                // need to be accessible on our scope for generation of the select options, and - for nested schemas -
                                // on baseScope for the conversion back to ids done by prepareForSave 
                                scope[schemaElement.ids] = ids;
                                scope[schemaElement.options] = options;
                            }
                        }
                        var data = getData($scope.record, schemaElement.name);
                        if (!data) {
                            return;
                        }
                        data = convertForeignKeys(schemaElement, data, options, ids);
                        setData($scope.record, schemaElement.name, undefined, data);
                    };
                },
                fillFormFromBackendCustomSchema: fillFormFromBackendCustomSchema,
                fillFormWithBackendSchema: function fillFormWithBackendSchema($scope, formGeneratorInstance, recordHandlerInstance, ctrlState) {
                    SchemasService.getSchema($scope.modelName, $scope.formName)
                        .then(function (response) {
                        var schema = response.data;
                        fillFormFromBackendCustomSchema(schema, $scope, formGeneratorInstance, recordHandlerInstance, ctrlState);
                    }, $scope.handleHttpError);
                }
            };
        }
        services.recordHandler = recordHandler;
    })(services = fng.services || (fng.services = {}));
})(fng || (fng = {}));
/// <reference path="../../../../node_modules/@types/angular/index.d.ts" />
var fng;
(function (fng) {
    var services;
    (function (services) {
        /*@ngInject*/
        SchemasService.$inject = ["$http"];
        function SchemasService($http) {
            return {
                getSchema: function (modelName, formName) {
                    return $http.get('/api/schema/' + modelName + (formName ? '/' + formName : ''), { cache: true });
                }
            };
        }
        services.SchemasService = SchemasService;
    })(services = fng.services || (fng.services = {}));
})(fng || (fng = {}));
/// <reference path="../../../../node_modules/@types/angular/index.d.ts" />
var ExpirationCache = /** @class */ (function () {
    function ExpirationCache(timeout) {
        if (timeout === void 0) { timeout = 60 * 1000; }
        this.store = new Map();
        this.timeout = timeout;
    }
    ExpirationCache.prototype.get = function (key) {
        // this.store.has(key) ? console.log(`cache hit`) : console.log(`cache miss`);
        return this.store.get(key);
    };
    ExpirationCache.prototype.put = function (key, val) {
        var _this = this;
        this.store.set(key, val);
        // remove it once it's expired
        setTimeout(function () {
            // console.log(`removing expired key ${key}`);
            _this.remove(key);
        }, this.timeout);
    };
    ExpirationCache.prototype.remove = function (key) {
        this.store.delete(key);
    };
    ExpirationCache.prototype.removeAll = function () {
        this.store = new Map();
    };
    ExpirationCache.prototype.delete = function () {
        //no op here because this is standalone, not a part of $cacheFactory
    };
    return ExpirationCache;
}());
var fng;
(function (fng) {
    var services;
    (function (services) {
        /*@ngInject*/
        SubmissionsService.$inject = ["$http"];
        function SubmissionsService($http) {
            var useCacheForGetAll = true;
            var expCache = new ExpirationCache();
            /*
             generate a query string for a filtered and paginated query for submissions.
             options consists of the following:
             {
             aggregate - whether or not to aggregate results (http://docs.mongodb.org/manual/aggregation/)
             find - find parameter
             limit - limit results to this number of records
             skip - skip this number of records before returning results
             order - sort order
             }
             */
            var generateListQuery = function (options) {
                var queryString = '';
                var addParameter = function (param, value) {
                    if (value !== undefined && value !== '') {
                        if (typeof value === 'object') {
                            value = JSON.stringify(value);
                        }
                        if (queryString === '') {
                            queryString = '?';
                        }
                        else {
                            queryString += '&';
                        }
                        queryString += param + '=' + value;
                    }
                };
                addParameter('l', options.limit);
                addParameter('f', options.find);
                addParameter('a', options.aggregate);
                addParameter('o', options.order);
                addParameter('s', options.skip);
                return queryString;
            };
            // TODO Figure out tab history updates (check for other tab-history-todos)
            //
            //     interface ITabChange {
            //       model: string;
            //       id: string;
            //       record: any;
            //       master: any;
            //       changed: boolean;
            //     }
            //
            //     let tabChangeData: ITabChange;
            return {
                // TODO Figure out tab history updates (check for other tab-history-todos)
                //       setUpForTabChange: function(model: string, id: string, data: any, original: any, changed: boolean) {
                //         tabChangeData = {
                //           model: model,
                //           id: id,
                //           record: data,
                //           master: original,
                //           changed: changed
                //         };
                //       },
                getListAttributes: function (ref, id) {
                    var actualId = typeof id === "string" ? id : id.id || id._id || id.x || id;
                    if (typeof actualId !== "string") {
                        throw new Error("getListAttributes requires a string id but was provided with ".concat(JSON.stringify(id)));
                    }
                    return $http.get('/api/' + ref + '/' + actualId + '/list', { cache: expCache });
                },
                readRecord: function (modelName, id) {
                    // TODO Figure out tab history updates (check for other tab-history-todos)
                    //         let retVal;
                    //         if (tabChangeData && tabChangeData.model === modelName && tabChangeData.id === id) {
                    //           retVal = Promise.resolve({data:tabChangeData.record, changed: tabChangeData.changed, master: tabChangeData.master});
                    //         } else {
                    return $http.get('/api/' + modelName + '/' + id);
                    //           retVal = $http.get('/api/' + modelName + '/' + id);
                    //         }
                    //         tabChangeData = null;
                    //         return retVal;
                },
                getAll: function (modelName, _options) {
                    var options = angular.extend({
                        cache: useCacheForGetAll ? expCache : false
                    }, _options);
                    return $http.get('/api/' + modelName, options);
                },
                getPagedAndFilteredList: function (modelName, options) {
                    return $http.get('/api/' + modelName + generateListQuery(options));
                },
                deleteRecord: function (model, id) {
                    return $http.delete('/api/' + model + '/' + id);
                },
                updateRecord: function (modelName, id, dataToSave) {
                    expCache.remove('/api/' + modelName);
                    return $http.post('/api/' + modelName + '/' + id, dataToSave);
                },
                createRecord: function (modelName, dataToSave) {
                    expCache.remove('/api/' + modelName);
                    return $http.post('/api/' + modelName, dataToSave);
                },
                useCache: function (val) {
                    useCacheForGetAll = val;
                },
                getCache: function () {
                    return !!expCache;
                },
                clearCache: function () {
                    expCache.removeAll();
                }
            };
        }
        services.SubmissionsService = SubmissionsService;
    })(services = fng.services || (fng.services = {}));
})(fng || (fng = {}));
/// <reference path="../../index.d.ts" />
var fng;
(function (fng) {
    var controllers;
    (function (controllers) {
        /*@ngInject*/
        BaseCtrl.$inject = ["$scope", "$rootScope", "$location", "$filter", "$uibModal", "fngModelCtrlService", "routingService", "formGenerator", "recordHandler"];
        function BaseCtrl($scope, $rootScope, $location, $filter, $uibModal, fngModelCtrlService, routingService, formGenerator, recordHandler) {
            $scope.sharedData = {
                record: {},
                disableFunctions: {},
                dataEventFunctions: {},
                modelControllers: []
            };
            var ctrlState = {
                master: {},
                fngInvalidRequired: 'fng-invalid-required',
                allowLocationChange: true // Set when the data arrives..
            };
            $scope.errorVisible = false;
            angular.extend($scope, routingService.parsePathFunc()($location.$$path));
            // Load context menu.  For /person/client/:id/edit we need
            // to load PersonCtrl and PersonClientCtrl
            var titleCaseModelName = $filter('titleCase')($scope.modelName, true);
            var needDivider = false;
            fngModelCtrlService.loadControllerAndMenu($scope.sharedData, titleCaseModelName, 0, needDivider, $scope.$new());
            if ($scope.formName) {
                fngModelCtrlService.loadControllerAndMenu($scope.sharedData, titleCaseModelName + $filter('titleCase')($scope.formName, true), 1, needDivider, $scope.$new());
            }
            $rootScope.$broadcast('fngControllersLoaded', $scope.sharedData, $scope.modelName);
            $scope.modelNameDisplay = $scope.sharedData.modelNameDisplay || $filter('titleCase')($scope.modelName);
            $rootScope.$broadcast('fngFormLoadStart', $scope);
            formGenerator.decorateScope($scope, formGenerator, recordHandler, $scope.sharedData);
            recordHandler.decorateScope($scope, $uibModal, recordHandler, ctrlState);
            function processTheForm() {
                recordHandler.fillFormWithBackendSchema($scope, formGenerator, recordHandler, ctrlState);
                // Tell the 'model controllers' that they can start fiddling with baseScope
                for (var i = 0; i < $scope.sharedData.modelControllers.length; i++) {
                    if ($scope.sharedData.modelControllers[i].onBaseCtrlReady) {
                        $scope.sharedData.modelControllers[i].onBaseCtrlReady($scope);
                    }
                }
                $scope.$on('$destroy', function () {
                    $scope.sharedData.modelControllers.forEach(function (value) { return value.$destroy(); });
                    $rootScope.$broadcast('fngControllersUnloaded');
                });
            }
            //Check that we are ready
            if (typeof fng.formsAngular.beforeProcess === "function") {
                fng.formsAngular.beforeProcess($scope, function (err) {
                    if (err) {
                        $scope.showError(err.message, 'Error preparing to process form');
                    }
                    else {
                        processTheForm();
                    }
                });
            }
            else {
                processTheForm();
            }
        }
        controllers.BaseCtrl = BaseCtrl;
    })(controllers = fng.controllers || (fng.controllers = {}));
})(fng || (fng = {}));
/// <reference path="../../../../node_modules/@types/angular/index.d.ts" />
var fng;
(function (fng) {
    var controllers;
    (function (controllers) {
        /*@ngInject*/
        SaveChangesModalCtrl.$inject = ["$scope", "$uibModalInstance"];
        function SaveChangesModalCtrl($scope, $uibModalInstance) {
            $scope.yes = function () {
                $uibModalInstance.close(true);
            };
            $scope.no = function () {
                $uibModalInstance.close(false);
            };
            $scope.cancel = function () {
                $uibModalInstance.dismiss('cancel');
            };
        }
        controllers.SaveChangesModalCtrl = SaveChangesModalCtrl;
    })(controllers = fng.controllers || (fng.controllers = {}));
})(fng || (fng = {}));
/// <reference path="../../../../node_modules/@types/angular/index.d.ts" />
var fng;
(function (fng) {
    var controllers;
    (function (controllers) {
        /*@ngInject*/
        ModelCtrl.$inject = ["$scope", "$http", "$location", "routingService"];
        function ModelCtrl($scope, $http, $location, routingService) {
            $scope.models = [];
            $http.get('/api/models').then(function (response) {
                $scope.models = response.data;
            }, function () {
                $location.path('/404');
            });
            $scope.newUrl = function (model) {
                return routingService.buildUrl(model + '/new');
            };
            $scope.listUrl = function (model) {
                return routingService.buildUrl(model);
            };
        }
        controllers.ModelCtrl = ModelCtrl;
    })(controllers = fng.controllers || (fng.controllers = {}));
})(fng || (fng = {}));
/// <reference path="../../../../node_modules/@types/angular/index.d.ts" />
var fng;
(function (fng) {
    var controllers;
    (function (controllers) {
        /*@ngInject*/
        NavCtrl.$inject = ["$rootScope", "$window", "$scope", "$location", "$filter", "routingService", "cssFrameworkService"];
        function NavCtrl($rootScope, $window, $scope, $location, $filter, routingService, cssFrameworkService) {
            function clearContextMenu() {
                $scope.items = [];
                $scope.contextMenu = undefined;
            }
            $rootScope.navScope = $scope; // Lets plugins access menus
            clearContextMenu();
            $scope.toggleCollapsed = function () {
                $scope.collapsed = !$scope.collapsed;
            };
            /* isCollapsed and showShortcuts are used to control how the menu is displayed in a responsive environment and whether the shortcut keystrokes help should be displayed */
            $scope.isCollapsed = true;
            $scope.showShortcuts = false;
            $scope.shortcuts = [
                { key: '?', act: 'Show shortcuts' },
                { key: '/', act: 'Jump to search' },
                { key: 'Ctrl+Shift+S', act: 'Save the current record' },
                { key: 'Ctrl+Shift+Esc', act: 'Cancel changes on the current record' },
                { key: 'Ctrl+Shift+Ins', act: 'Create a new record' },
                { key: 'Ctrl+Shift+X', act: 'Delete the current record' }
            ];
            $scope.markupShortcut = function (keys) {
                return '<span class="key">' + keys.split('+').join('</span> + <span class="key">') + '</span>';
            };
            $scope.globalShortcuts = function (event) {
                function deferredBtnClick(id) {
                    var btn = document.getElementById(id);
                    if (btn) {
                        if (!btn.disabled) {
                            setTimeout(function () {
                                btn.click();
                            });
                        }
                        event.preventDefault();
                    }
                }
                function filter(event) {
                    var tagName = (event.target).tagName;
                    return !(tagName == 'INPUT' || tagName == 'SELECT' || tagName == 'TEXTAREA' || tagName == "DIV" && event.target.classList.contains('ck-editor__editable'));
                }
                //console.log(event.keyCode, event.ctrlKey, event.shiftKey, event.altKey, event.metaKey);
                if (event.keyCode === 191 && (filter(event) || (event.ctrlKey && !event.altKey && !event.metaKey))) {
                    if (event.ctrlKey || !event.shiftKey) {
                        var searchInput = document.getElementById('searchinput');
                        if (searchInput) {
                            searchInput.focus();
                            event.preventDefault();
                        }
                    }
                    else {
                        $scope.showShortcuts = true;
                    }
                }
                else if (event.keyCode === 83 && event.ctrlKey && event.shiftKey && !event.altKey && !event.metaKey) {
                    deferredBtnClick('saveButton'); // Ctrl+Shift+S saves changes
                }
                else if (event.keyCode === 27 && ((event.ctrlKey && event.shiftKey && !event.altKey && !event.metaKey) || $scope.showShortcuts)) {
                    if (event.ctrlKey && event.shiftKey && !event.altKey && !event.metaKey) {
                        deferredBtnClick('cancelButton'); // Ctrl+Shift+Esc cancels updates
                    }
                    else {
                        $scope.showShortcuts = false;
                    }
                }
                else if (event.keyCode === 45 && event.ctrlKey && event.shiftKey && !event.altKey && !event.metaKey) {
                    deferredBtnClick('newButton'); // Ctrl+Shift+Ins creates New record
                }
                else if (event.keyCode === 88 && event.ctrlKey && event.shiftKey && !event.altKey && !event.metaKey) {
                    deferredBtnClick('deleteButton'); // Ctrl+Shift+X deletes record
                }
            };
            $scope.css = function (fn, arg) {
                var result;
                if (typeof cssFrameworkService[fn] === 'function') {
                    result = cssFrameworkService[fn](arg);
                }
                else {
                    result = 'error text-error';
                }
                return result;
            };
            $scope.$on('fngControllersLoaded', function (evt, sharedData, modelName) {
                $scope.contextMenu = sharedData.dropDownDisplay || sharedData.modelNameDisplay || $filter('titleCase')(modelName, false);
                if (sharedData.dropDownDisplayPromise) {
                    sharedData.dropDownDisplayPromise.then(function (value) {
                        $scope.contextMenu = value;
                    });
                }
            });
            $scope.$on('fngControllersUnloaded', function (evt) {
                clearContextMenu();
            });
            $scope.doClick = function (index, event) {
                var option = angular.element(event.target);
                var item = $scope.items[index];
                if (item.divider || option.parent().hasClass('disabled')) {
                    event.preventDefault();
                }
                else if (item.broadcast) {
                    $scope.$broadcast(item.broadcast);
                }
                else {
                    // Performance optimization: http://jsperf.com/apply-vs-call-vs-invoke
                    var args = item.args || [];
                    var fn = item.fn;
                    if (typeof fn === "function") {
                        switch (args.length) {
                            case 0:
                                fn();
                                break;
                            case 1:
                                fn(args[0]);
                                break;
                            case 2:
                                fn(args[0], args[1]);
                                break;
                            case 3:
                                fn(args[0], args[1], args[2]);
                                break;
                            case 4:
                                fn(args[0], args[1], args[2], args[3]);
                                break;
                        }
                    }
                    else if (fn) {
                        throw new Error("Incorrect menu setup");
                    }
                }
            };
            $scope.isHidden = function (index) {
                function explicitlyHidden(item) {
                    return item.isHidden ? item.isHidden() : false;
                }
                var dividerHide = false;
                // Hide a divider if it appears under another
                if ($scope.items[index].divider) {
                    if (index === 0) {
                        dividerHide = true;
                    }
                    else {
                        var foundVisible = false;
                        var check = index - 1;
                        while (check >= 0 && !dividerHide && !foundVisible) {
                            if ($scope.items[check].divider) {
                                dividerHide = true;
                            }
                            else if (!explicitlyHidden($scope.items[check])) {
                                foundVisible = true;
                            }
                            else {
                                --check;
                            }
                        }
                    }
                }
                return dividerHide || explicitlyHidden($scope.items[index]);
            };
            $scope.isDisabled = function (index) {
                return $scope.items[index].isDisabled ? $scope.items[index].isDisabled() : false;
            };
            $scope.buildUrl = function (path) {
                return routingService.buildUrl(path);
            };
            $scope.dropdownClass = function (index) {
                var item = $scope.items[index];
                var thisClass = '';
                if (item.divider) {
                    thisClass = 'divider';
                }
                else if ($scope.isDisabled(index)) {
                    thisClass = 'disabled';
                }
                return thisClass;
            };
            var originalTitle = $window.document.title;
            $scope.$on('$routeChangeSuccess', function () {
                $window.document.title = originalTitle;
            });
        }
        controllers.NavCtrl = NavCtrl;
    })(controllers = fng.controllers || (fng.controllers = {}));
})(fng || (fng = {}));
/// <reference path="../../../node_modules/@types/angular/index.d.ts" />
/// <reference path="controllers/base.ts" />
/// <reference path="controllers/saveChangesModal.ts" />
/// <reference path="controllers/model.ts" />
/// <reference path="controllers/nav.ts" />
/// <reference path="controllers/search-ctrl.ts" />
/// <reference path="directives/dropdown.ts" />
/// <reference path="directives/error-display.ts" />
/// <reference path="directives/fng-link.ts" />
/// <reference path="directives/form.ts" />
/// <reference path="directives/form-buttons.ts" />
/// <reference path="directives/search.ts" />
/// <reference path="filters/camelcase.ts" />
/// <reference path="filters/titlecase.ts" />
/// <reference path="services/add-all.ts" />
/// <reference path="services/css-framework.ts" />
/// <reference path="services/fng-model-controller.ts" />
/// <reference path="services/fng-routes.ts" />
/// <reference path="services/form-generator.ts" />
/// <reference path="services/form-markup-helper.ts" />
/// <reference path="services/input-size-helper.ts" />
/// <reference path="services/plugin-helper.ts" />
/// <reference path="services/record-handler.ts" />
/// <reference path="services/schemas.ts" />
/// <reference path="services/submissions.ts" />
var fng;
(function (fng) {
    fng.formsAngular = angular.module('formsAngular', [
        'ngSanitize',
        'ngMessages',
        'ui.bootstrap',
        'infinite-scroll',
        'monospaced.elastic'
    ])
        .controller('BaseCtrl', fng.controllers.BaseCtrl)
        .controller('SaveChangesModalCtrl', fng.controllers.SaveChangesModalCtrl)
        .controller('LinkCtrl', fng.controllers.LinkCtrl)
        .controller('ModelCtrl', fng.controllers.ModelCtrl)
        .controller('NavCtrl', fng.controllers.NavCtrl)
        .directive('modelControllerDropdown', fng.directives.modelControllerDropdown)
        .directive('errorDisplay', fng.directives.errorDisplay)
        .directive('fngLink', fng.directives.fngLink)
        .directive('formInput', fng.directives.formInput)
        .directive('formButtons', fng.directives.formButtons)
        .directive('globalSearch', fng.directives.globalSearch)
        .directive('fngNakedDate', fng.directives.fngNakedDate)
        .filter('camelCase', fng.filters.camelCase)
        .filter('titleCase', fng.filters.titleCase)
        .filter('extractTimestampFromMongoID', fng.filters.extractTimestampFromMongoID)
        .service('addAllService', fng.services.addAllService)
        .provider('cssFrameworkService', fng.services.cssFrameworkService)
        .provider('routingService', fng.services.routingService)
        .factory('fngModelCtrlService', fng.services.fngModelCtrlService)
        .factory('formGenerator', fng.services.formGenerator)
        .factory('formMarkupHelper', fng.services.formMarkupHelper)
        .factory('inputSizeHelper', fng.services.inputSizeHelper)
        .factory('pluginHelper', fng.services.pluginHelper)
        .factory('recordHandler', fng.services.recordHandler)
        .factory('SchemasService', fng.services.SchemasService)
        .factory('SubmissionsService', fng.services.SubmissionsService);
})(fng || (fng = {}));
// expose the library
var formsAngular = fng.formsAngular;

angular.module('formsAngular').run(['$templateCache', function($templateCache) {$templateCache.put('base-analysis.html','<div ng-controller="AnalysisCtrl">\n  <error-display></error-display>\n  <div class="container-fluid page-header report-header">\n    <div ng-class="css(\'rowFluid\')">\n      <div class="header-lhs col-xs-7 span7">\n        <h1>{{ titleWithSubstitutions }}</h1>\n      </div>\n      <div class="header-rhs col-xs-5 span5">\n        <form-input schema="paramSchema" name="paramForm" ng-show="paramSchema" formstyle="horizontalCompact"></form-input>\n      </div>\n    </div>\n  </div>\n  <div class="container-fluid page-body report-body">\n    <div class="row-fluid report-grow">\n      <div class="gridStyle" style="height:100%;" ui-grid="gridOptions" ui-grid-selection ui-grid-resize-columns></div>\n    </div>\n  </div>\n</div>\n');
$templateCache.put('base-edit.html','<div ng-controller="BaseCtrl">\n    <error-display></error-display>\n    <div ng-hide="phase == \'ready\'" class="loading">Loading&#8230;</div>\n    <div ng-class="css(\'rowFluid\')" class="page-header edit-header">\n        <div class="header-lhs col-sm-8 span8">\n            <h1 id="header-text">{{modelNameDisplay}} :\n                <span id="header-data-desc">\n                    <span ng-show="!!editFormHeader" >{{ editFormHeader() }}</span>\n                    <span ng-hide="!!editFormHeader" ng-repeat="field in listSchema" ng-bind-html="getListData(record, field.name) + \' \'"></span>\n                </span>\n            </h1>\n        </div>\n        <div class="header-rhs col-sm-2 span2">\n            <div form-buttons></div>\n        </div>\n    </div>\n    <div class="container-fluid page-body edit-body">\n        <form-input name="baseForm" schema="baseSchema()" formstyle="compact"></form-input>\n    </div>\n<!--    <pre>-->\n    <!--Record-->\n    <!--{{ record | json }}-->\n    <!--formSchema-->\n    <!--{{ formSchema | json }}-->\n<!--    </pre>-->\n</div>\n');
$templateCache.put('base-list-view.html','<div ng-controller="BaseCtrl">\n    <error-display></error-display>\n    <div ng-class="css(\'rowFluid\')" class="page-header list-header">\n        <div class="header-lhs col-sm-8 span8">\n            <h1>{{modelNameDisplay}}</h1>\n        </div>\n    </div>\n    <div class="page-body list-body">\n        <div ng-class="css(\'rowFluid\')" infinite-scroll="scrollTheList()">\n            <a ng-repeat="record in recordList" ng-href="{{generateViewUrl(record)}}">\n                <div class="list-item">\n                    <div ng-class="css(\'span\',12/listSchema.length)" ng-repeat="field in listSchema">{{getListData(record, field.name)}} </div>\n                </div>\n            </a>\n        </div>\n    </div>\n</div>\n');
$templateCache.put('base-list.html','<div ng-controller="BaseCtrl">\n    <error-display></error-display>\n    <div ng-class="css(\'rowFluid\')" class="page-header list-header">\n        <div class="header-lhs col-sm-8 span8">\n            <h1>{{modelNameDisplay}}</h1>\n        </div>\n        <div class="header-rhs col-sm-2 span2">\n            <a ng-href="{{generateNewUrl()}}"><button id="newBtn" class="btn btn-default"><i class="icon-plus"></i> New</button></a>\n        </div>\n    </div>\n    <div class="page-body list-body">\n        <div ng-class="css(\'rowFluid\')" infinite-scroll="scrollTheList()">\n            <a ng-repeat="record in recordList" ng-href="{{generateEditUrl(record)}}">\n                <div class="list-item">\n                    <div ng-class="css(\'span\',12/listSchema.length)" ng-repeat="field in listSchema">{{getListData(record, field.name)}} </div>\n                </div>\n            </a>\n        </div>\n    </div>\n</div>\n');
$templateCache.put('base-view.html','<div ng-controller="BaseCtrl">\n    <error-display></error-display>\n    <div ng-class="css(\'rowFluid\')" class="page-header edit-header">\n        <div class="header-lhs col-sm-8 span8">\n            <h1 id="header-text">{{modelNameDisplay}} :\n                <span ng-repeat="field in listSchema" ng-bind-html="getListData(record, field.name) + \' \'"></span>\n            </h1>\n        </div>\n    </div>\n    <div class="container-fluid page-body edit-body">\n        <form-input name="baseForm" schema="baseSchema()" formstyle="compact" viewform="true"></form-input>\n    </div>\n</div>\n');
$templateCache.put('error-display-bs2.html','<div id="display-error" ng-show="errorVisible" class="row-fluid ng-hide">\n    <div class="alert alert-error offset1 span10">\n        <button type="button" id="err-hide" class="close" ng-click="dismissError()"><i class="icon-remove"></i></button>\n        <button type="button" id="err-pin" class="close" ng-click="stickError()"><i class="icon-eye-open"></i></button>\n        <h4 id="err-title">{{alertTitle}}</h4>\n        <div id="err-msg" ng-bind-html="errorMessage"></div>\n    </div>\n</div>\n');
$templateCache.put('error-display-bs3.html','<div id="display-error" ng-show="errorVisible" class="row ng-hide">\n    <div class="alert alert-error col-md-offset-1 col-md-10 alert-danger">\n        <button type="button" id="err-hide" class="close" ng-click="dismissError()"><i class="glyphicon glyphicon-remove"></i></button>\n        <button type="button" id="err-pin" class="close" ng-click="stickError()"><i class="glyphicon glyphicon-pushpin"></i></button>\n        <h4 id="err-title">{{alertTitle}}</h4>\n        <div id="err-msg" ng-bind-html="errorMessage"></div>\n    </div>\n</div>\n');
$templateCache.put('error-messages.html','<div ng-message="required">A value is required for this field</div>\n<div ng-message="minlength">Too few characters entered</div>\n<div ng-message="maxlength">Too many characters entered</div>\n<div ng-message="min">That value is too small</div>\n<div ng-message="max">That value is too large</div>\n<div ng-message="email">You need to enter a valid email address</div>\n<div ng-message="pattern">This field does not match the expected pattern</div>\n');
$templateCache.put('form-button-bs2.html','<div class="form-btn-grp">\n  <div class="btn-group pull-right">\n    <button id="saveButton" class="btn btn-mini btn-primary form-btn" ng-click="save()" ng-disabled="isSaveDisabled()"><i class="icon-ok"></i> Save</button>\n    <div id="why-disabled" ng-class="{showwhy:!!whyDisabled}" ng-bind-html="whyDisabled"></div>\n    <button id="cancelButton" class="btn btn-mini btn-warning form-btn" ng-click="cancel()" ng-disabled="isCancelDisabled()"><i class="icon-remove"></i> Cancel</button>\n  </div>\n  <div class="btn-group pull-right">\n    <button id="newButton" class="btn btn-mini btn-success form-btn" ng-click="newClick()" ng-disabled="isNewDisabled()"><i class="icon-plus"></i> New</button>\n    <button id="deleteButton" class="btn btn-mini btn-danger form-btn" ng-click="deleteClick()" ng-disabled="isDeleteDisabled()"><i class="icon-minus"></i> Delete</button>\n  </div>\n</div>\n');
$templateCache.put('form-button-bs3.html','<div class="form-btn-grp">\n  <div class="btn-group pull-right">\n    <button id="saveButton" class="btn btn-primary form-btn btn-xs" ng-click="save()" ng-disabled="isSaveDisabled()"><i class="glyphicon glyphicon-ok"></i> Save</button>\n    <div id="why-disabled" ng-class="{showwhy:!!whyDisabled}" ng-bind-html="whyDisabled"></div>\n    <button id="cancelButton" class="btn btn-warning form-btn btn-xs" ng-click="cancel()" ng-disabled="isCancelDisabled()"><i class="glyphicon glyphicon-remove"></i> Cancel</button>\n  </div>\n  <div class="btn-group pull-right">\n    <button id="newButton" class="btn btn-success form-btn btn-xs" ng-click="newClick()" ng-disabled="isNewDisabled()"><i class="glyphicon glyphicon-plus"></i> New</button>\n    <button id="deleteButton" class="btn btn-danger form-btn btn-xs" ng-click="deleteClick()" ng-disabled="isDeleteDisabled()"><i class="glyphicon glyphicon-minus"></i> Delete</button>\n  </div>\n</div>\n');
$templateCache.put('search-bs2.html','<form class="navbar-search pull-right">\n    <div id="search-cg" class="control-group" ng-class="errorClass">\n        <input type="text" spellcheck="false" autocomplete="off" id="searchinput" ng-model="searchTarget" ng-model-options="{debounce:250}" class="search-query" placeholder="{{searchPlaceholder}}" ng-keyup="handleKey($event)">\n    </div>\n</form>\n<div class="results-container" ng-show="results.length >= 1">\n    <div class="search-results">\n        <div ng-repeat="result in results">\n            <a href="{{result.href}}" ng-class="resultClass($index)" title="{{result.additional}}">{{result.resourceText}} {{result.text}}</a>\n        </div>\n        <div ng-show="moreCount > 0">(plus more - continue typing to narrow down search...)\n        </div>\n    </div>\n</div>\n');
$templateCache.put('search-bs3.html','<form class="pull-right navbar-form">\n    <div id="search-cg" class="form-group" ng-class="errorClass">\n        <input type="text" spellcheck="false" autocomplete="off" id="searchinput" ng-model="searchTarget" ng-model-options="{debounce:250}" class="search-query form-control" placeholder="{{searchPlaceholder}}" ng-keyup="handleKey($event)">\n    </div>\n</form>\n<div class="results-container" ng-show="results.length >= 1">\n    <div class="search-results">\n        <div ng-repeat="result in results">\n            <a href="{{result.href}}" ng-class="resultClass($index)" title="{{result.additional}}">{{result.resourceText}} {{result.text}}</a>\n        </div>\n        <div ng-show="moreCount > 0">(plus more - continue typing to narrow down search...)\n        </div>\n    </div>\n</div>\n');}]);