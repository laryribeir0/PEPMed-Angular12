"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FormsAngular = void 0;
// This part of forms-angular borrows _very_ heavily from https://github.com/Alexandre-Strzelewicz/angular-bridge
// (now https://github.com/Unitech/angular-bridge
var _ = require('lodash');
var util = require('util');
var extend = require('node.extend');
var async = require('async');
var debug = false;
function logTheAPICalls(req, res, next) {
    void (res);
    console.log('API     : ' + req.method + ' ' + req.url + '  [ ' + JSON.stringify(req.body) + ' ]');
    next();
}
function processArgs(options, array) {
    if (options.authentication) {
        var authArray = _.isArray(options.authentication) ? options.authentication : [options.authentication];
        for (var i = authArray.length - 1; i >= 0; i--) {
            array.splice(1, 0, authArray[i]);
        }
    }
    if (debug) {
        array.splice(1, 0, logTheAPICalls);
    }
    array[0] = options.urlPrefix + array[0];
    return array;
}
var FormsAngular = /** @class */ (function () {
    function FormsAngular(mongoose, app, options) {
        this.mongoose = mongoose;
        this.app = app;
        app.locals.formsAngular = app.locals.formsAngular || [];
        app.locals.formsAngular.push(this);
        mongoose.set('debug', debug);
        mongoose.Promise = global.Promise;
        this.options = _.extend({
            urlPrefix: '/api/'
        }, options || {});
        this.resources = [];
        this.searchFunc = async.forEach;
        var search = 'search/', schema = 'schema/', report = 'report/', resourceName = ':resourceName', id = '/:id';
        this.app.get.apply(this.app, processArgs(this.options, ['models', this.models()]));
        this.app.get.apply(this.app, processArgs(this.options, [search + resourceName, this.search()]));
        this.app.get.apply(this.app, processArgs(this.options, [schema + resourceName, this.schema()]));
        this.app.get.apply(this.app, processArgs(this.options, [schema + resourceName + '/:formName', this.schema()]));
        this.app.get.apply(this.app, processArgs(this.options, [report + resourceName, this.report()]));
        this.app.get.apply(this.app, processArgs(this.options, [report + resourceName + '/:reportName', this.report()]));
        this.app.get.apply(this.app, processArgs(this.options, [resourceName, this.collectionGet()]));
        this.app.post.apply(this.app, processArgs(this.options, [resourceName, this.collectionPost()]));
        this.app.get.apply(this.app, processArgs(this.options, [resourceName + id, this.entityGet()]));
        this.app.post.apply(this.app, processArgs(this.options, [resourceName + id, this.entityPut()])); // You can POST or PUT to update data
        this.app.put.apply(this.app, processArgs(this.options, [resourceName + id, this.entityPut()]));
        this.app.delete.apply(this.app, processArgs(this.options, [resourceName + id, this.entityDelete()]));
        // return the List attributes for a record - used by select2
        this.app.get.apply(this.app, processArgs(this.options, [resourceName + id + '/list', this.entityList()]));
        this.app.get.apply(this.app, processArgs(this.options, ['search', this.searchAll()]));
        for (var pluginName in this.options.plugins) {
            if (this.options.plugins.hasOwnProperty(pluginName)) {
                var pluginObj = this.options.plugins[pluginName];
                this.options.plugins[pluginName] = Object.assign(this.options.plugins[pluginName], pluginObj.plugin(this, processArgs, pluginObj.options));
            }
        }
    }
    FormsAngular.prototype.getListFields = function (resource, doc, cb) {
        function getFirstMatchingField(keyList, type) {
            for (var i = 0; i < keyList.length; i++) {
                var fieldDetails = resource.model.schema['tree'][keyList[i]];
                if (fieldDetails.type && (!type || fieldDetails.type.name === type) && keyList[i] !== '_id') {
                    resource.options.listFields = [{ field: keyList[i] }];
                    return doc[keyList[i]];
                }
            }
        }
        var that = this;
        var display = '';
        var listFields = resource.options.listFields;
        if (listFields) {
            async.map(listFields, function (aField, cbm) {
                if (typeof doc[aField.field] !== 'undefined') {
                    if (aField.params) {
                        if (aField.params.ref) {
                            var fieldOptions = resource.model.schema['paths'][aField.field].options;
                            if (typeof fieldOptions.ref === 'string') {
                                var lookupResource_1 = that.getResource(fieldOptions.ref);
                                if (lookupResource_1) {
                                    var hiddenFields = that.generateHiddenFields(lookupResource_1, false);
                                    hiddenFields.__v = false;
                                    lookupResource_1.model.findOne({ _id: doc[aField.field] }).select(hiddenFields).exec(function (err, doc2) {
                                        if (err) {
                                            cbm(err);
                                        }
                                        else {
                                            that.getListFields(lookupResource_1, doc2, cbm);
                                        }
                                    });
                                }
                            }
                            else {
                                throw new Error('No support for ref type ' + aField.params.ref.type);
                            }
                        }
                        else if (aField.params.params === 'timestamp') {
                            var date = that.extractTimestampFromMongoID(doc[aField.field]);
                            cbm(null, date.toLocaleDateString() + ' ' + date.toLocaleTimeString());
                        }
                    }
                    else {
                        cbm(null, doc[aField.field]);
                    }
                }
                else {
                    cbm(null, '');
                }
            }, function (err, results) {
                if (err) {
                    cb(err);
                }
                else {
                    if (results) {
                        cb(err, results.join(' ').trim());
                    }
                    else {
                        console.log('No results ' + listFields);
                    }
                }
            });
        }
        else {
            var keyList = Object.keys(resource.model.schema['tree']);
            // No list field specified - use the first String field,
            display = getFirstMatchingField(keyList, 'String') ||
                // and if there aren't any then just take the first field
                getFirstMatchingField(keyList);
            cb(null, display.trim());
        }
    };
    ;
    FormsAngular.prototype.newResource = function (model, options) {
        options = options || {};
        options.suppressDeprecatedMessage = true;
        var passModel = model;
        if (typeof model !== 'function') {
            passModel = model.model;
        }
        this.addResource(passModel.modelName, passModel, options);
    };
    ;
    //    Add a resource, specifying the model and any options.
    //    Models may include their own options, which means they can be passed through from the model file
    FormsAngular.prototype.addResource = function (resourceName, model, options) {
        var resource = {
            resourceName: resourceName,
            options: options || {}
        };
        if (!resource.options.suppressDeprecatedMessage) {
            console.log('addResource is deprecated - see https://github.com/forms-angular/forms-angular/issues/39');
        }
        if (typeof model === 'function') {
            resource.model = model;
        }
        else {
            resource.model = model.model;
            for (var prop in model) {
                if (model.hasOwnProperty(prop) && prop !== 'model') {
                    resource.options[prop] = model[prop];
                }
            }
        }
        extend(resource.options, this.preprocess(resource, resource.model.schema['paths'], null));
        if (resource.options.searchImportance) {
            this.searchFunc = async.forEachSeries;
        }
        if (this.searchFunc === async.forEachSeries) {
            this.resources.splice(_.sortedIndexBy(this.resources, resource, function (obj) {
                return obj.options.searchImportance || 99;
            }), 0, resource);
        }
        else {
            this.resources.push(resource);
        }
    };
    ;
    FormsAngular.prototype.getResource = function (name) {
        return _.find(this.resources, function (resource) {
            return resource.resourceName === name;
        });
    };
    ;
    FormsAngular.prototype.getResourceFromCollection = function (name) {
        return _.find(this.resources, function (resource) {
            return resource.model.collection.collectionName === name;
        });
    };
    ;
    FormsAngular.prototype.internalSearch = function (req, resourcesToSearch, includeResourceInResults, limit, callback) {
        var _a, _b, _c, _d;
        if (typeof req.query === 'undefined') {
            req.query = {};
        }
        var timestamps = { sentAt: req.query.sentAt, startedAt: new Date().valueOf(), completedAt: undefined };
        var searches = [], resourceCount = resourcesToSearch.length, searchFor = req.query.q || '', filter = req.query.f;
        function translate(string, array, context) {
            if (array) {
                var translation = _.find(array, function (fromTo) {
                    return fromTo.from === string && (!fromTo.context || fromTo.context === context);
                });
                if (translation) {
                    string = translation.to;
                }
            }
            return string;
        }
        // return a string that determines the sort order of the resultObject
        function calcResultValue(obj) {
            function padLeft(score, reqLength, str) {
                if (str === void 0) { str = '0'; }
                return new Array(1 + reqLength - String(score).length).join(str) + score;
            }
            var sortString = '';
            sortString += padLeft(obj.addHits || 9, 1);
            sortString += padLeft(obj.searchImportance || 99, 2);
            sortString += padLeft(obj.weighting || 9999, 4);
            sortString += obj.text;
            return sortString;
        }
        if (filter) {
            filter = JSON.parse(filter);
        }
        // See if we are narrowing down the resources
        var collectionName;
        var collectionNameLower;
        var colonPos = searchFor.indexOf(':');
        switch (colonPos) {
            case -1:
                // Original behaviour = do nothing different
                break;
            case 0:
                // "Special search" - yet to be implemented
                break;
            default:
                collectionName = searchFor.slice(0, colonPos);
                collectionNameLower = collectionName.toLowerCase();
                searchFor = searchFor.slice(colonPos + 1, 999);
                if (searchFor === '') {
                    searchFor = '?';
                }
                break;
        }
        for (var i = 0; i < resourceCount; i++) {
            var resource = resourcesToSearch[i];
            if (resourceCount === 1 || (resource.options.searchImportance !== false && (!collectionName || collectionName === resource.resourceName || ((_b = (_a = resource.options) === null || _a === void 0 ? void 0 : _a.synonyms) === null || _b === void 0 ? void 0 : _b.find(function (s) { var _a; return ((_a = s.name) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === collectionNameLower; }))))) {
                var schema = resource.model.schema;
                var indexedFields = [];
                for (var j = 0; j < schema._indexes.length; j++) {
                    var attributes = schema._indexes[j][0];
                    var field = Object.keys(attributes)[0];
                    if (indexedFields.indexOf(field) === -1) {
                        indexedFields.push(field);
                    }
                }
                for (var path in schema.paths) {
                    if (path !== '_id' && schema.paths.hasOwnProperty(path)) {
                        if (schema.paths[path]._index && !schema.paths[path].options.noSearch) {
                            if (indexedFields.indexOf(path) === -1) {
                                indexedFields.push(path);
                            }
                        }
                    }
                }
                if (indexedFields.length === 0) {
                    console.log('ERROR: Searching on a collection with no indexes ' + resource.resourceName);
                }
                var synonymObj = (_d = (_c = resource.options) === null || _c === void 0 ? void 0 : _c.synonyms) === null || _d === void 0 ? void 0 : _d.find(function (s) { return s.name.toLowerCase() === collectionNameLower; });
                var synonymFilter = synonymObj === null || synonymObj === void 0 ? void 0 : synonymObj.filter;
                for (var m = 0; m < indexedFields.length; m++) {
                    var searchObj = { resource: resource, field: indexedFields[m] };
                    if (synonymFilter) {
                        searchObj.filter = synonymFilter;
                    }
                    searches.push(searchObj);
                }
            }
        }
        var that = this;
        var results = [];
        var moreCount = 0;
        var searchCriteria;
        var searchStrings;
        var multiMatchPossible = false;
        if (searchFor === '?') {
            // interpret this as a wildcard (so there is no way to search for ?
            searchCriteria = null;
        }
        else {
            // Support for searching anywhere in a field by starting with *
            var startAnchor = '^';
            if (searchFor.slice(0, 1) === '*') {
                startAnchor = '';
                searchFor = searchFor.slice(1);
            }
            // THe snippet to escape the special characters comes from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions
            searchFor = searchFor.replace(/[.*+\-?^${}()|[\]\\]/g, '\\$&');
            multiMatchPossible = searchFor.includes(' ');
            if (multiMatchPossible) {
                searchStrings = searchFor.split(' ');
            }
            var modifiedSearchStr = multiMatchPossible ? searchStrings.join('|') : searchFor;
            searchFor = searchFor.toLowerCase(); // For later case-insensitive comparison
            // Removed the logic that preserved spaces when collection was specified because Louise asked me to.
            searchCriteria = { $regex: "".concat(startAnchor, "(").concat(modifiedSearchStr, ")"), $options: 'i' };
        }
        var handleSearchResultsFromIndex = function (err, docs, item, cb) {
            function handleSingleSearchResult(aDoc, cbdoc) {
                var thisId = aDoc._id.toString(), resultObject, resultPos;
                function handleResultsInList() {
                    if (multiMatchPossible) {
                        resultObject.matched = resultObject.matched || [];
                        // record the index of string that matched, so we don't count it against another field
                        for (var i = 0; i < searchStrings.length; i++) {
                            if (aDoc[item.field].toLowerCase().indexOf(searchStrings[i]) === 0) {
                                resultObject.matched.push(i);
                                break;
                            }
                        }
                    }
                    resultObject.searchImportance = item.resource.options.searchImportance || 99;
                    if (item.resource.options.localisationData) {
                        resultObject.resource = translate(resultObject.resource, item.resource.options.localisationData, "resource");
                        resultObject.resourceText = translate(resultObject.resourceText, item.resource.options.localisationData, "resourceText");
                        resultObject.resourceTab = translate(resultObject.resourceTab, item.resource.options.localisationData, "resourceTab");
                    }
                    results.splice(_.sortedIndexBy(results, resultObject, calcResultValue), 0, resultObject);
                    cbdoc(null);
                }
                // Do we already have them in the list?
                for (resultPos = results.length - 1; resultPos >= 0; resultPos--) {
                    if (results[resultPos].id.toString() === thisId) {
                        break;
                    }
                }
                if (resultPos >= 0) {
                    resultObject = Object.assign({}, results[resultPos]);
                    // If they have already matched then improve their weighting
                    if (multiMatchPossible) {
                        // record the index of string that matched, so we don't count it against another field
                        for (var i = 0; i < searchStrings.length; i++) {
                            if (!resultObject.matched.includes(i) && aDoc[item.field].toLowerCase().indexOf(searchStrings[i]) === 0) {
                                resultObject.matched.push(i);
                                resultObject.addHits = Math.max((resultObject.addHits || 9) - 1, 0);
                                // remove it from current position
                                results.splice(resultPos, 1);
                                // and re-insert where appropriate
                                results.splice(_.sortedIndexBy(results, resultObject, calcResultValue), 0, resultObject);
                                break;
                            }
                        }
                    }
                    cbdoc(null);
                }
                else {
                    // Otherwise add them new...
                    var addHits_1;
                    if (multiMatchPossible)
                        // If they match the whole search phrase in one index they get smaller addHits (so they sort higher)
                        if (aDoc[item.field].toLowerCase().indexOf(searchFor) === 0) {
                            addHits_1 = 7;
                        }
                    // Use special listings format if defined
                    var specialListingFormat = item.resource.options.searchResultFormat;
                    if (specialListingFormat) {
                        specialListingFormat.apply(aDoc, [req])
                            .then(function (resultObj) {
                            resultObject = resultObj;
                            resultObject.addHits = addHits_1;
                            handleResultsInList();
                        });
                    }
                    else {
                        that.getListFields(item.resource, aDoc, function (err, description) {
                            if (err) {
                                cbdoc(err);
                            }
                            else {
                                resultObject = {
                                    id: aDoc._id,
                                    weighting: 9999,
                                    addHits: addHits_1,
                                    text: description
                                };
                                if (resourceCount > 1 || includeResourceInResults) {
                                    resultObject.resource = resultObject.resourceText = item.resource.resourceName;
                                }
                                handleResultsInList();
                            }
                        });
                    }
                }
            }
            if (!err && docs && docs.length > 0) {
                async.map(docs, handleSingleSearchResult, cb);
            }
            else {
                cb(err);
            }
        };
        this.searchFunc(searches, function (item, cb) {
            var searchDoc = {};
            var searchFilter = filter || item.filter;
            if (searchFilter) {
                that.hackVariables(searchFilter);
                extend(searchDoc, searchFilter);
                if (searchFilter[item.field]) {
                    delete searchDoc[item.field];
                    var obj1 = {}, obj2 = {};
                    obj1[item.field] = searchFilter[item.field];
                    obj2[item.field] = searchCriteria;
                    searchDoc['$and'] = [obj1, obj2];
                }
                else {
                    if (searchCriteria) {
                        searchDoc[item.field] = searchCriteria;
                    }
                }
            }
            else {
                if (searchCriteria) {
                    searchDoc[item.field] = searchCriteria;
                }
            }
            /*
            The +200 below line is an (imperfect) arbitrary safety zone for situations where items that match the string in more than one index get filtered out.
            An example where it fails is searching for "e c" which fails to get a old record Emily Carpenter in a big dataset sorted by date last accessed as they
            are not returned within the first 200 in forenames so don't get the additional hit score and languish outside the visible results, though those visible
            results end up containing people who only match either c or e (but have been accessed much more recently).

            Increasing the number would be a short term fix at the cost of slowing down the search.
             */
            // TODO : Figure out a better way to deal with this
            if (item.resource.options.searchFunc) {
                item.resource.options.searchFunc(item.resource, req, null, searchDoc, item.resource.options.searchOrder, limit ? limit + 200 : 0, null, function (err, docs) {
                    handleSearchResultsFromIndex(err, docs, item, cb);
                });
            }
            else {
                that.filteredFind(item.resource, req, null, searchDoc, null, item.resource.options.searchOrder, limit ? limit + 200 : 0, null, function (err, docs) {
                    handleSearchResultsFromIndex(err, docs, item, cb);
                });
            }
        }, function (err) {
            if (err) {
                callback(err);
            }
            else {
                // Strip weighting from the results
                results = _.map(results, function (aResult) {
                    delete aResult.weighting;
                    return aResult;
                });
                if (limit && results.length > limit) {
                    moreCount += results.length - limit;
                    results.splice(limit);
                }
                timestamps.completedAt = new Date().valueOf();
                callback(null, { results: results, moreCount: moreCount, timestamps: timestamps });
            }
        });
    };
    ;
    FormsAngular.prototype.wrapInternalSearch = function (req, res, resourcesToSearch, includeResourceInResults, limit) {
        this.internalSearch(req, resourcesToSearch, includeResourceInResults, limit, function (err, resultsObject) {
            if (err) {
                res.status(400, err);
            }
            else {
                res.send(resultsObject);
            }
        });
    };
    ;
    FormsAngular.prototype.search = function () {
        return _.bind(function (req, res, next) {
            if (!(req.resource = this.getResource(req.params.resourceName))) {
                return next();
            }
            this.wrapInternalSearch(req, res, [req.resource], false, 0);
        }, this);
    };
    ;
    FormsAngular.prototype.searchAll = function () {
        return _.bind(function (req, res) {
            this.wrapInternalSearch(req, res, this.resources, true, 10);
        }, this);
    };
    ;
    FormsAngular.prototype.models = function () {
        var that = this;
        return function (req, res) {
            //    TODO: Make this less wasteful - we only need to send the resourceNames of the resources
            // Check for optional modelFilter and call it with the request and current list.  Otherwise just return the list.
            res.send(that.options.modelFilter ? that.options.modelFilter.call(null, req, that.resources) : that.resources);
        };
    };
    ;
    FormsAngular.prototype.renderError = function (err, redirectUrl, req, res) {
        res.statusMessage = (err === null || err === void 0 ? void 0 : err.message) || err;
        res.status(400).end((err === null || err === void 0 ? void 0 : err.message) || err);
    };
    ;
    FormsAngular.prototype.redirect = function (address, req, res) {
        res.send(address);
    };
    ;
    FormsAngular.prototype.applySchemaSubset = function (vanilla, schema) {
        var outPath;
        if (schema) {
            outPath = {};
            for (var fld in schema) {
                if (schema.hasOwnProperty(fld)) {
                    if (vanilla[fld]) {
                        outPath[fld] = _.cloneDeep(vanilla[fld]);
                        if (vanilla[fld].schema) {
                            outPath[fld].schema = this.applySchemaSubset(outPath[fld].schema, schema[fld].schema);
                        }
                    }
                    else {
                        if (fld.slice(0, 8) === "_bespoke") {
                            outPath[fld] = {
                                "path": fld,
                                "instance": schema[fld]._type,
                            };
                        }
                        else {
                            throw new Error('No such field as ' + fld + '.  Is it part of a sub-doc? If so you need the bit before the period.');
                        }
                    }
                    outPath[fld].options = outPath[fld].options || {};
                    for (var override in schema[fld]) {
                        if (schema[fld].hasOwnProperty(override)) {
                            if (override.slice(0, 1) !== '_') {
                                if (schema[fld].hasOwnProperty(override)) {
                                    if (!outPath[fld].options.form) {
                                        outPath[fld].options.form = {};
                                    }
                                    outPath[fld].options.form[override] = schema[fld][override];
                                }
                            }
                        }
                    }
                }
            }
        }
        else {
            outPath = vanilla;
        }
        return outPath;
    };
    ;
    FormsAngular.prototype.preprocess = function (resource, paths, formSchema) {
        var outPath = {}, hiddenFields = [], listFields = [];
        if (resource && resource.options && resource.options.idIsList) {
            paths['_id'].options = paths['_id'].options || {};
            paths['_id'].options.list = resource.options.idIsList;
        }
        for (var element in paths) {
            if (paths.hasOwnProperty(element) && element !== '__v') {
                // check for schemas
                if (paths[element].schema) {
                    var subSchemaInfo = this.preprocess(null, paths[element].schema.paths);
                    outPath[element] = { schema: subSchemaInfo.paths };
                    if (paths[element].options.form) {
                        outPath[element].options = { form: extend(true, {}, paths[element].options.form) };
                    }
                    // this provides support for entire nested schemas that wish to remain hidden
                    if (paths[element].options.secure) {
                        hiddenFields.push(element);
                    }
                    // to support hiding individual properties of nested schema would require us
                    // to do something with subSchemaInfo.hide here
                }
                else {
                    // check for arrays
                    var realType = paths[element].caster ? paths[element].caster : paths[element];
                    if (!realType.instance) {
                        if (realType.options.type) {
                            var type = realType.options.type(), typeType = typeof type;
                            if (typeType === 'string') {
                                realType.instance = (!isNaN(Date.parse(type))) ? 'Date' : 'String';
                            }
                            else {
                                realType.instance = typeType;
                            }
                        }
                    }
                    outPath[element] = extend(true, {}, paths[element]);
                    if (paths[element].options.secure) {
                        hiddenFields.push(element);
                    }
                    if (paths[element].options.match) {
                        outPath[element].options.match = paths[element].options.match.source || paths[element].options.match;
                    }
                    var schemaListInfo = paths[element].options.list;
                    if (schemaListInfo) {
                        var listFieldInfo = { field: element };
                        if (typeof schemaListInfo === 'object' && Object.keys(schemaListInfo).length > 0) {
                            listFieldInfo.params = schemaListInfo;
                        }
                        listFields.push(listFieldInfo);
                    }
                }
            }
        }
        outPath = this.applySchemaSubset(outPath, formSchema);
        var returnObj = { paths: outPath };
        if (hiddenFields.length > 0) {
            returnObj.hide = hiddenFields;
        }
        if (listFields.length > 0) {
            returnObj.listFields = listFields;
        }
        return returnObj;
    };
    ;
    FormsAngular.prototype.schema = function () {
        return _.bind(function (req, res) {
            if (!(req.resource = this.getResource(req.params.resourceName))) {
                return res.status(404).end();
            }
            var formSchema = null;
            if (req.params.formName) {
                formSchema = req.resource.model.schema.statics['form'](req.params.formName, req);
            }
            var paths = this.preprocess(req.resource, req.resource.model.schema.paths, formSchema).paths;
            res.send(paths);
        }, this);
    };
    ;
    FormsAngular.prototype.report = function () {
        return _.bind(function (req, res, next) {
            return __awaiter(this, void 0, void 0, function () {
                var self, reportSchema, fields, key, schemaCopy;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!(req.resource = this.getResource(req.params.resourceName))) {
                                return [2 /*return*/, next()];
                            }
                            self = this;
                            if (typeof req.query === 'undefined') {
                                req.query = {};
                            }
                            if (!req.params.reportName) return [3 /*break*/, 2];
                            return [4 /*yield*/, req.resource.model.schema.statics['report'](req.params.reportName, req)];
                        case 1:
                            reportSchema = _a.sent();
                            return [3 /*break*/, 3];
                        case 2:
                            if (req.query.r) {
                                switch (req.query.r[0]) {
                                    case '[':
                                        reportSchema = { pipeline: JSON.parse(req.query.r) };
                                        break;
                                    case '{':
                                        reportSchema = JSON.parse(req.query.r);
                                        break;
                                    default:
                                        return [2 /*return*/, self.renderError(new Error('Invalid "r" parameter'), null, req, res)];
                                }
                            }
                            else {
                                fields = {};
                                for (key in req.resource.model.schema.paths) {
                                    if (req.resource.model.schema.paths.hasOwnProperty(key)) {
                                        if (key !== '__v' && !req.resource.model.schema.paths[key].options.secure) {
                                            if (key.indexOf('.') === -1) {
                                                fields[key] = 1;
                                            }
                                        }
                                    }
                                }
                                reportSchema = {
                                    pipeline: [
                                        { $project: fields }
                                    ], drilldown: req.params.resourceName + '/|_id|/edit'
                                };
                            }
                            _a.label = 3;
                        case 3:
                            schemaCopy = {};
                            extend(schemaCopy, reportSchema);
                            schemaCopy.params = schemaCopy.params || [];
                            self.reportInternal(req, req.resource, schemaCopy, function (err, result) {
                                if (err) {
                                    res.send({ success: false, error: err.message || err });
                                }
                                else {
                                    res.send(result);
                                }
                            });
                            return [2 /*return*/];
                    }
                });
            });
        }, this);
    };
    ;
    FormsAngular.prototype.hackVariablesInPipeline = function (runPipeline) {
        for (var pipelineSection = 0; pipelineSection < runPipeline.length; pipelineSection++) {
            if (runPipeline[pipelineSection]['$match']) {
                this.hackVariables(runPipeline[pipelineSection]['$match']);
            }
        }
    };
    ;
    FormsAngular.prototype.hackVariables = function (obj) {
        // Replace variables that cannot be serialised / deserialised.  Bit of a hack, but needs must...
        // Anything formatted 1800-01-01T00:00:00.000Z or 1800-01-01T00:00:00.000+0000 is converted to a Date
        // Only handles the cases I need for now
        // TODO: handle arrays etc
        for (var prop in obj) {
            if (obj.hasOwnProperty(prop)) {
                if (typeof obj[prop] === 'string') {
                    var dateTest = /^(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3})(Z|[+ -]\d{4})$/.exec(obj[prop]);
                    if (dateTest) {
                        obj[prop] = new Date(dateTest[1] + 'Z');
                    }
                    else {
                        var objectIdTest = /^([0-9a-fA-F]{24})$/.exec(obj[prop]);
                        if (objectIdTest) {
                            obj[prop] = new this.mongoose.Types.ObjectId(objectIdTest[1]);
                        }
                    }
                }
                else if (_.isObject(obj[prop])) {
                    this.hackVariables(obj[prop]);
                }
            }
        }
    };
    ;
    FormsAngular.prototype.sanitisePipeline = function (aggregationParam, hiddenFields, findFuncQry) {
        var _a, _b, _c, _d;
        var that = this;
        var array = Array.isArray(aggregationParam) ? aggregationParam : [aggregationParam];
        var retVal = [];
        var doneHiddenFields = false;
        if (findFuncQry) {
            retVal.unshift({ $match: findFuncQry });
        }
        var _loop_1 = function (pipelineSection) {
            var stage = array[pipelineSection];
            var keys = Object.keys(stage);
            if (keys.length !== 1) {
                throw new Error('Invalid pipeline instruction');
            }
            switch (keys[0]) {
                case '$merge':
                case '$out':
                    throw new Error('Cannot use potentially destructive pipeline stages');
                case '$unionWith':
                    /*
                        Sanitise the pipeline we are doing a union with, removing hidden fields from that collection
                     */
                    var unionCollectionName = stage.$unionWith.coll;
                    var unionResource = that.getResourceFromCollection(unionCollectionName);
                    var unionHiddenLookupFields = {};
                    if (unionResource) {
                        if (((_b = (_a = unionResource.options) === null || _a === void 0 ? void 0 : _a.hide) === null || _b === void 0 ? void 0 : _b.length) > 0) {
                            unionHiddenLookupFields = this_1.generateHiddenFields(unionResource, false);
                        }
                    }
                    stage.$unionWith.pipeline = that.sanitisePipeline(stage.$unionWith.pipeline, unionHiddenLookupFields, findFuncQry);
                    break;
                case '$match':
                    this_1.hackVariables(array[pipelineSection]['$match']);
                    retVal.push(array[pipelineSection]);
                    if (!doneHiddenFields && Object.keys(hiddenFields) && Object.keys(hiddenFields).length > 0) {
                        // We can now project out the hidden fields (we wait for the $match to make sure we don't break
                        // a select that uses a hidden field
                        retVal.push({ $project: hiddenFields });
                        doneHiddenFields = true;
                    }
                    stage = null;
                    break;
                case '$lookup':
                    // hide any hiddenfields in the lookup collection
                    var collectionName = stage.$lookup.from;
                    var lookupField_1 = stage.$lookup.as;
                    if ((collectionName + lookupField_1).indexOf('$') !== -1) {
                        throw new Error('No support for lookups where the "from" or "as" is anything other than a simple string');
                    }
                    var resource = that.getResourceFromCollection(collectionName);
                    if (resource) {
                        if (((_d = (_c = resource.options) === null || _c === void 0 ? void 0 : _c.hide) === null || _d === void 0 ? void 0 : _d.length) > 0) {
                            var hiddenLookupFields = this_1.generateHiddenFields(resource, false);
                            var hiddenFieldsObj_1 = {};
                            Object.keys(hiddenLookupFields).forEach(function (hf) {
                                hiddenFieldsObj_1["".concat(lookupField_1, ".").concat(hf)] = false;
                            });
                            retVal.push({ $project: hiddenFieldsObj_1 });
                        }
                    }
                    break;
                default:
                    // nothing
                    break;
            }
            if (stage) {
                retVal.push(stage);
            }
        };
        var this_1 = this;
        for (var pipelineSection = 0; pipelineSection < array.length; pipelineSection++) {
            _loop_1(pipelineSection);
        }
        if (!doneHiddenFields && Object.keys(hiddenFields) && Object.keys(hiddenFields).length > 0) {
            // If there was no $match we still need to hide the hidden fields
            retVal.unshift({ $project: hiddenFields });
        }
        return retVal;
    };
    FormsAngular.prototype.reportInternal = function (req, resource, schema, callback) {
        var runPipelineStr;
        var runPipelineObj;
        var self = this;
        if (typeof req.query === 'undefined') {
            req.query = {};
        }
        self.doFindFunc(req, resource, function (err, queryObj) {
            if (err) {
                return 'There was a problem with the findFunc for model';
            }
            else {
                runPipelineStr = JSON.stringify(schema.pipeline);
                for (var param in req.query) {
                    if (req.query.hasOwnProperty(param)) {
                        if (req.query[param]) {
                            if (param !== 'r') { // we don't want to copy the whole report schema (again!)
                                if (schema.params[param] !== undefined) {
                                    schema.params[param].value = req.query[param];
                                }
                                else {
                                    callback("No such parameter as ".concat(param, " - try one of ").concat(Object.keys(schema.params).join()));
                                }
                            }
                        }
                    }
                }
                // Replace parameters with the value
                if (runPipelineStr) {
                    runPipelineStr = runPipelineStr.replace(/"\(.+?\)"/g, function (match) {
                        var sparam = schema.params[match.slice(2, -2)];
                        if (sparam !== undefined) {
                            if (sparam.type === 'number') {
                                return sparam.value;
                            }
                            else if (_.isObject(sparam.value)) {
                                return JSON.stringify(sparam.value);
                            }
                            else if (sparam.value[0] === '{') {
                                return sparam.value;
                            }
                            else {
                                return '"' + sparam.value + '"';
                            }
                        }
                        else {
                            callback("No such parameter as ".concat(match.slice(2, -2), " - try one of ").concat(Object.keys(schema.params).join()));
                        }
                    });
                }
                runPipelineObj = JSON.parse(runPipelineStr);
                var hiddenFields_1 = self.generateHiddenFields(resource, false);
                var toDo = {
                    runAggregation: function (cb) {
                        runPipelineObj = self.sanitisePipeline(runPipelineObj, hiddenFields_1, queryObj);
                        resource.model.aggregate(runPipelineObj, cb);
                    }
                };
                var translations_1 = []; // array of form {ref:'lookupname',translations:[{value:xx, display:'  '}]}
                // if we need to do any column translations add the function to the tasks list
                if (schema.columnTranslations) {
                    toDo.applyTranslations = ['runAggregation', function (results, cb) {
                            function doATranslate(column, theTranslation) {
                                results['runAggregation'].forEach(function (resultRow) {
                                    var valToTranslate = resultRow[column.field];
                                    valToTranslate = (valToTranslate ? valToTranslate.toString() : '');
                                    var thisTranslation = _.find(theTranslation.translations, function (option) {
                                        return valToTranslate === option.value.toString();
                                    });
                                    resultRow[column.field] = thisTranslation ? thisTranslation.display : ' * Missing columnTranslation * ';
                                });
                            }
                            schema.columnTranslations.forEach(function (columnTranslation) {
                                if (columnTranslation.translations) {
                                    doATranslate(columnTranslation, columnTranslation);
                                }
                                if (columnTranslation.ref) {
                                    var theTranslation = _.find(translations_1, function (translation) {
                                        return (translation.ref === columnTranslation.ref);
                                    });
                                    if (theTranslation) {
                                        doATranslate(columnTranslation, theTranslation);
                                    }
                                    else {
                                        cb('Invalid ref property of ' + columnTranslation.ref + ' in columnTranslations ' + columnTranslation.field);
                                    }
                                }
                            });
                            cb(null, null);
                        }];
                    var callFuncs = false;
                    for (var i = 0; i < schema.columnTranslations.length; i++) {
                        var thisColumnTranslation = schema.columnTranslations[i];
                        if (thisColumnTranslation.field) {
                            // if any of the column translations are adhoc funcs, set up the tasks to perform them
                            if (thisColumnTranslation.fn) {
                                callFuncs = true;
                            }
                            // if this column translation is a "ref", set up the tasks to look up the values and populate the translations
                            if (thisColumnTranslation.ref) {
                                var lookup = self.getResource(thisColumnTranslation.ref);
                                if (lookup) {
                                    if (!toDo[thisColumnTranslation.ref]) {
                                        var getFunc = function (ref) {
                                            var lookup = ref;
                                            return function (cb) {
                                                var translateObject = { ref: lookup.resourceName, translations: [] };
                                                translations_1.push(translateObject);
                                                lookup.model.find({}, {}, { lean: true }, function (err, findResults) {
                                                    if (err) {
                                                        cb(err);
                                                    }
                                                    else {
                                                        // TODO - this ref func can probably be done away with now that list fields can have ref
                                                        var j_1 = 0;
                                                        async.whilst(function (cbtest) {
                                                            cbtest(null, j_1 < findResults.length);
                                                        }, function (cbres) {
                                                            var theResult = findResults[j_1];
                                                            translateObject.translations[j_1] = translateObject.translations[j_1] || {};
                                                            var theTranslation = translateObject.translations[j_1];
                                                            j_1++;
                                                            self.getListFields(lookup, theResult, function (err, description) {
                                                                if (err) {
                                                                    cbres(err);
                                                                }
                                                                else {
                                                                    theTranslation.value = theResult._id;
                                                                    theTranslation.display = description;
                                                                    cbres(null);
                                                                }
                                                            });
                                                        }, cb);
                                                    }
                                                });
                                            };
                                        };
                                        toDo[thisColumnTranslation.ref] = getFunc(lookup);
                                        toDo.applyTranslations.unshift(thisColumnTranslation.ref); // Make sure we populate lookup before doing translation
                                    }
                                }
                                else {
                                    return callback('Invalid ref property of ' + thisColumnTranslation.ref + ' in columnTranslations ' + thisColumnTranslation.field);
                                }
                            }
                            if (!thisColumnTranslation.translations && !thisColumnTranslation.ref && !thisColumnTranslation.fn) {
                                return callback('A column translation needs a ref, fn or a translations property - ' + thisColumnTranslation.field + ' has neither');
                            }
                        }
                        else {
                            return callback('A column translation needs a field property');
                        }
                    }
                    if (callFuncs) {
                        toDo['callFunctions'] = ['runAggregation', function (results, cb) {
                                async.each(results.runAggregation, function (row, cb) {
                                    for (var i = 0; i < schema.columnTranslations.length; i++) {
                                        var thisColumnTranslation = schema.columnTranslations[i];
                                        if (thisColumnTranslation.fn) {
                                            thisColumnTranslation.fn(row, cb);
                                        }
                                    }
                                }, function () {
                                    cb(null);
                                });
                            }];
                        toDo.applyTranslations.unshift('callFunctions'); // Make sure we do function before translating its result
                    }
                }
                async.auto(toDo, function (err, results) {
                    if (err) {
                        callback(err);
                    }
                    else {
                        // TODO: Could loop through schema.params and just send back the values
                        callback(null, {
                            success: true,
                            schema: schema,
                            report: results.runAggregation,
                            paramsUsed: schema.params
                        });
                    }
                });
            }
        });
    };
    ;
    FormsAngular.prototype.saveAndRespond = function (req, res, hiddenFields) {
        function internalSave(doc) {
            doc.save(function (err, doc2) {
                if (err) {
                    var err2 = { status: 'err' };
                    if (!err.errors) {
                        err2.message = err.message;
                    }
                    else {
                        extend(err2, err);
                    }
                    if (debug) {
                        console.log('Error saving record: ' + JSON.stringify(err2));
                    }
                    res.status(400).send(err2);
                }
                else {
                    doc2 = doc2.toObject();
                    for (var hiddenField in hiddenFields) {
                        if (hiddenFields.hasOwnProperty(hiddenField) && hiddenFields[hiddenField]) {
                            var parts = hiddenField.split('.');
                            var lastPart = parts.length - 1;
                            var target = doc2;
                            for (var i = 0; i < lastPart; i++) {
                                if (target.hasOwnProperty(parts[i])) {
                                    target = target[parts[i]];
                                }
                            }
                            if (target.hasOwnProperty(parts[lastPart])) {
                                delete target[parts[lastPart]];
                            }
                        }
                    }
                    res.send(doc2);
                }
            });
        }
        var doc = req.doc;
        if (typeof req.resource.options.onSave === 'function') {
            req.resource.options.onSave(doc, req, function (err) {
                if (err) {
                    throw err;
                }
                internalSave(doc);
            });
        }
        else {
            internalSave(doc);
        }
    };
    ;
    /**
     * All entities REST functions have to go through this first.
     */
    FormsAngular.prototype.processCollection = function (req) {
        req.resource = this.getResource(req.params.resourceName);
    };
    ;
    /**
     * Renders a view with the list of docs, which may be modified by query parameters
     */
    FormsAngular.prototype.collectionGet = function () {
        return _.bind(function (req, res, next) {
            this.processCollection(req);
            if (!req.resource) {
                return next();
            }
            if (typeof req.query === 'undefined') {
                req.query = {};
            }
            try {
                var aggregationParam = req.query.a ? JSON.parse(req.query.a) : null;
                var findParam = req.query.f ? JSON.parse(req.query.f) : {};
                var projectParam = req.query.p ? JSON.parse(req.query.p) : {};
                var limitParam = req.query.l ? JSON.parse(req.query.l) : 0;
                var skipParam = req.query.s ? JSON.parse(req.query.s) : 0;
                var orderParam = req.query.o ? JSON.parse(req.query.o) : req.resource.options.listOrder;
                // Dates in aggregation must be Dates
                if (aggregationParam) {
                    this.hackVariablesInPipeline(aggregationParam);
                }
                var self_1 = this;
                this.filteredFind(req.resource, req, aggregationParam, findParam, projectParam, orderParam, limitParam, skipParam, function (err, docs) {
                    if (err) {
                        return self_1.renderError(err, null, req, res);
                    }
                    else {
                        res.send(docs);
                    }
                });
            }
            catch (e) {
                res.status(400).send(e.message);
            }
        }, this);
    };
    ;
    FormsAngular.prototype.generateProjection = function (hiddenFields, projectParam) {
        var type;
        function setSelectType(typeChar, checkChar) {
            if (type === checkChar) {
                throw new Error('Cannot mix include and exclude fields in select');
            }
            else {
                type = typeChar;
            }
        }
        var retVal = hiddenFields;
        if (projectParam) {
            var projection = Object.keys(projectParam);
            if (projection.length > 0) {
                projection.forEach(function (p) {
                    if (projectParam[p] === 0) {
                        setSelectType('E', 'I');
                    }
                    else if (projectParam[p] === 1) {
                        setSelectType('I', 'E');
                    }
                    else {
                        throw new Error('Invalid projection: ' + projectParam);
                    }
                });
                if (type && type === 'E') {
                    // We are excluding fields - can just merge with hiddenFields
                    Object.assign(retVal, projectParam, hiddenFields);
                }
                else {
                    // We are selecting fields - make sure none are hidden
                    retVal = projectParam;
                    for (var h in hiddenFields) {
                        if (hiddenFields.hasOwnProperty(h)) {
                            delete retVal[h];
                        }
                    }
                }
            }
        }
        return retVal;
    };
    ;
    FormsAngular.prototype.doFindFunc = function (req, resource, cb) {
        if (resource.options.findFunc) {
            resource.options.findFunc(req, cb);
        }
        else {
            cb(null);
        }
    };
    ;
    FormsAngular.prototype.filteredFind = function (resource, req, aggregationParam, findParam, projectParam, sortOrder, limit, skip, callback) {
        var that = this;
        var hiddenFields = this.generateHiddenFields(resource, false);
        var stashAggregationResults;
        function doAggregation(queryObj, cb) {
            if (aggregationParam) {
                aggregationParam = that.sanitisePipeline(aggregationParam, hiddenFields, queryObj);
                void resource.model.aggregate(aggregationParam, function (err, aggregationResults) {
                    if (err) {
                        throw err;
                    }
                    else {
                        stashAggregationResults = aggregationResults;
                        cb(_.map(aggregationResults, function (obj) {
                            return obj._id;
                        }));
                    }
                });
            }
            else {
                cb([]);
            }
        }
        that.doFindFunc(req, resource, function (err, queryObj) {
            if (err) {
                callback(err);
            }
            else {
                doAggregation(queryObj, function (idArray) {
                    if (aggregationParam && idArray.length === 0) {
                        callback(null, []);
                    }
                    else {
                        var query = resource.model.find(queryObj);
                        if (idArray.length > 0) {
                            query = query.where('_id').in(idArray);
                        }
                        if (findParam) {
                            query = query.find(findParam);
                        }
                        query = query.select(that.generateProjection(hiddenFields, projectParam));
                        if (limit) {
                            query = query.limit(limit);
                        }
                        if (skip) {
                            query = query.skip(skip);
                        }
                        if (sortOrder) {
                            query = query.sort(sortOrder);
                        }
                        query.exec(function (err, docs) {
                            if (!err && stashAggregationResults) {
                                docs.forEach(function (obj) {
                                    // Add any fields from the aggregation results whose field name starts __ to the mongoose Document
                                    var aggObj = stashAggregationResults.find(function (a) { return a._id.toString() === obj._id.toString(); });
                                    Object.keys(aggObj).forEach(function (k) {
                                        if (k.slice(0, 2) === '__') {
                                            obj[k] = aggObj[k];
                                        }
                                    });
                                });
                            }
                            callback(err, docs);
                        });
                    }
                });
            }
        });
    };
    ;
    FormsAngular.prototype.collectionPost = function () {
        return _.bind(function (req, res, next) {
            this.processCollection(req);
            if (!req.resource) {
                next();
                return;
            }
            if (!req.body) {
                throw new Error('Nothing submitted.');
            }
            var cleansedBody = this.cleanseRequest(req);
            req.doc = new req.resource.model(cleansedBody);
            this.saveAndRespond(req, res);
        }, this);
    };
    ;
    /**
     * Generate an object of fields to not expose
     **/
    FormsAngular.prototype.generateHiddenFields = function (resource, state) {
        var hiddenFields = {};
        if (resource.options['hide'] !== undefined) {
            resource.options.hide.forEach(function (dt) {
                hiddenFields[dt] = state;
            });
        }
        return hiddenFields;
    };
    ;
    /** Sec issue
     * Cleanse incoming data to avoid overwrite and POST request forgery
     * (name may seem weird but it was in French, so it is some small improvement!)
     */
    FormsAngular.prototype.cleanseRequest = function (req) {
        var reqData = req.body, resource = req.resource;
        delete reqData.__v; // Don't mess with Mongoose internal field (https://github.com/LearnBoost/mongoose/issues/1933)
        if (typeof resource.options['hide'] === 'undefined') {
            return reqData;
        }
        var hiddenFields = resource.options.hide;
        _.each(reqData, function (num, key) {
            _.each(hiddenFields, function (fi) {
                if (fi === key) {
                    delete reqData[key];
                }
            });
        });
        return reqData;
    };
    ;
    FormsAngular.prototype.generateQueryForEntity = function (req, resource, id, cb) {
        var that = this;
        var hiddenFields = this.generateHiddenFields(resource, false);
        hiddenFields.__v = false;
        that.doFindFunc(req, resource, function (err, queryObj) {
            var _a;
            if (err) {
                cb(err);
            }
            else {
                var idSel = { _id: id };
                var crit = void 0;
                if (queryObj) {
                    if (queryObj._id) {
                        crit = { $and: [idSel, { _id: queryObj._id }] };
                        delete queryObj._id;
                        if (Object.keys(queryObj).length > 0) {
                            crit = extend(crit, queryObj);
                        }
                    }
                    else {
                        crit = extend(queryObj, idSel);
                    }
                }
                else {
                    crit = idSel;
                }
                cb(null, resource.model.findOne(crit).select(that.generateProjection(hiddenFields, (_a = req.query) === null || _a === void 0 ? void 0 : _a.p)));
            }
        });
    };
    ;
    /*
     * Entity request goes here first
     * It retrieves the resource
     */
    FormsAngular.prototype.processEntity = function (req, res, next) {
        if (!(req.resource = this.getResource(req.params.resourceName))) {
            next();
            return;
        }
        this.generateQueryForEntity(req, req.resource, req.params.id, function (err, query) {
            if (err) {
                return res.status(500).send({
                    success: false,
                    err: util.inspect(err)
                });
            }
            else {
                query.exec(function (err, doc) {
                    if (err) {
                        return res.status(400).send({
                            success: false,
                            err: util.inspect(err)
                        });
                    }
                    else if (doc == null) {
                        return res.status(404).send({
                            success: false,
                            err: 'Record not found'
                        });
                    }
                    req.doc = doc;
                    next();
                });
            }
        });
    };
    ;
    /**
     * Gets a single entity
     *
     * @return {Function} The function to use as route
     */
    FormsAngular.prototype.entityGet = function () {
        return _.bind(function (req, res, next) {
            this.processEntity(req, res, function () {
                if (!req.resource) {
                    return next();
                }
                if (req.resource.options.onAccess) {
                    req.resource.options.onAccess(req, function () {
                        return res.status(200).send(req.doc);
                    });
                }
                else {
                    return res.status(200).send(req.doc);
                }
            });
        }, this);
    };
    ;
    FormsAngular.prototype.replaceHiddenFields = function (record, data) {
        var self = this;
        if (record) {
            record._replacingHiddenFields = true;
            _.each(data, function (value, name) {
                if (_.isObject(value) && !Array.isArray(value)) {
                    self.replaceHiddenFields(record[name], value);
                }
                else if (!record[name]) {
                    record[name] = value;
                }
            });
            delete record._replacingHiddenFields;
        }
    };
    ;
    FormsAngular.prototype.entityPut = function () {
        return _.bind(function (req, res, next) {
            var that = this;
            this.processEntity(req, res, function () {
                if (!req.resource) {
                    next();
                    return;
                }
                if (!req.body) {
                    throw new Error('Nothing submitted.');
                }
                var cleansedBody = that.cleanseRequest(req);
                // Merge
                for (var prop in cleansedBody) {
                    if (cleansedBody.hasOwnProperty(prop)) {
                        req.doc.set(prop, cleansedBody[prop] === '' ? undefined : cleansedBody[prop]);
                    }
                }
                if (req.resource.options.hide !== undefined) {
                    var hiddenFields_2 = that.generateHiddenFields(req.resource, true);
                    hiddenFields_2._id = false;
                    req.resource.model.findById(req.doc._id, hiddenFields_2, { lean: true }, function (err, data) {
                        that.replaceHiddenFields(req.doc, data);
                        that.saveAndRespond(req, res, hiddenFields_2);
                    });
                }
                else {
                    that.saveAndRespond(req, res);
                }
            });
        }, this);
    };
    ;
    FormsAngular.prototype.entityDelete = function () {
        var that = this;
        return _.bind(function (req, res, next) {
            return __awaiter(this, void 0, void 0, function () {
                function generateDependencyList(resource) {
                    if (resource.options.dependents === undefined) {
                        resource.options.dependents = that.resources.reduce(function (acc, r) {
                            function searchPaths(schema, prefix) {
                                var fldList = [];
                                for (var fld in schema.paths) {
                                    if (schema.paths.hasOwnProperty(fld)) {
                                        var parts = fld.split('.');
                                        var schemaType = schema.tree;
                                        while (parts.length > 0) {
                                            schemaType = schemaType[parts.shift()];
                                        }
                                        if (schemaType.type) {
                                            if (schemaType.type.name === 'ObjectId' && schemaType.ref === resource.resourceName) {
                                                fldList.push(prefix + fld);
                                            }
                                            else if (_.isArray(schemaType.type)) {
                                                schemaType.type.forEach(function (t) {
                                                    searchPaths(t, prefix + fld + '.');
                                                });
                                            }
                                        }
                                    }
                                }
                                if (fldList.length > 0) {
                                    acc.push({ resource: r, keys: fldList });
                                }
                            }
                            searchPaths(r.model.schema, '');
                            return acc;
                        }, []);
                        for (var pluginName in that.options.plugins) {
                            var thisPlugin = that.options.plugins[pluginName];
                            if (thisPlugin.dependencyChecks && thisPlugin.dependencyChecks[resource.resourceName]) {
                                resource.options.dependents = resource.options.dependents.concat(thisPlugin.dependencyChecks[resource.resourceName]);
                            }
                        }
                    }
                }
                function removeDoc(doc, resource) {
                    return __awaiter(this, void 0, void 0, function () {
                        var promises_1;
                        return __generator(this, function (_a) {
                            switch (resource.options.handleRemove) {
                                case 'allow':
                                    // old behaviour - no attempt to maintain data integrity
                                    return [2 /*return*/, doc.remove()];
                                case 'cascade':
                                    generateDependencyList(resource);
                                    res.status(400).send('"cascade" option not yet supported');
                                    break;
                                default:
                                    generateDependencyList(resource);
                                    promises_1 = [];
                                    resource.options.dependents.forEach(function (collection) {
                                        collection.keys.forEach(function (key) {
                                            var _a;
                                            promises_1.push({
                                                p: collection.resource.model.find((_a = {}, _a[key] = doc._id, _a)).limit(1).exec(),
                                                collection: collection,
                                                key: key
                                            });
                                        });
                                    });
                                    return [2 /*return*/, Promise.all(promises_1.map(function (p) { return p.p; }))
                                            .then(function (results) {
                                            results.forEach(function (r, i) {
                                                if (r.length > 0) {
                                                    throw new ForeignKeyError(resource.resourceName, promises_1[i].collection.resource.resourceName, promises_1[i].key, r[0]._id);
                                                }
                                            });
                                            return doc.remove();
                                        })];
                            }
                            return [2 /*return*/];
                        });
                    });
                }
                function runDeletion(doc, resource) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, new Promise(function (resolve) {
                                    if (resource.options.onRemove) {
                                        resource.options.onRemove(doc, req, function (err) {
                                            return __awaiter(this, void 0, void 0, function () {
                                                return __generator(this, function (_a) {
                                                    if (err) {
                                                        throw err;
                                                    }
                                                    resolve(removeDoc(doc, resource));
                                                    return [2 /*return*/];
                                                });
                                            });
                                        });
                                    }
                                    else {
                                        resolve(removeDoc(doc, resource));
                                    }
                                })];
                        });
                    });
                }
                return __generator(this, function (_a) {
                    this.processEntity(req, res, function () {
                        return __awaiter(this, void 0, void 0, function () {
                            var doc, e_1;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        if (!req.resource) {
                                            next();
                                            return [2 /*return*/];
                                        }
                                        doc = req.doc;
                                        _a.label = 1;
                                    case 1:
                                        _a.trys.push([1, 3, , 4]);
                                        return [4 /*yield*/, runDeletion(doc, req.resource)];
                                    case 2:
                                        void (_a.sent());
                                        res.status(200).send();
                                        return [3 /*break*/, 4];
                                    case 3:
                                        e_1 = _a.sent();
                                        if (e_1 instanceof ForeignKeyError) {
                                            res.status(400).send(e_1.message);
                                        }
                                        else {
                                            res.status(500).send(e_1.message);
                                        }
                                        return [3 /*break*/, 4];
                                    case 4: return [2 /*return*/];
                                }
                            });
                        });
                    });
                    return [2 /*return*/];
                });
            });
        }, this);
    };
    ;
    FormsAngular.prototype.entityList = function () {
        return _.bind(function (req, res, next) {
            var that = this;
            this.processEntity(req, res, function () {
                if (!req.resource) {
                    return next();
                }
                that.getListFields(req.resource, req.doc, function (err, display) {
                    if (err) {
                        return res.status(500).send(err);
                    }
                    else {
                        return res.send({ list: display });
                    }
                });
            });
        }, this);
    };
    ;
    FormsAngular.prototype.extractTimestampFromMongoID = function (record) {
        var timestamp = record.toString().substring(0, 8);
        return new Date(parseInt(timestamp, 16) * 1000);
    };
    return FormsAngular;
}());
exports.FormsAngular = FormsAngular;
var ForeignKeyError = /** @class */ (function (_super) {
    __extends(ForeignKeyError, _super);
    function ForeignKeyError(resourceName, foreignKeyOnResource, foreignItem, id) {
        var _this = _super.call(this, "Cannot delete this ".concat(resourceName, ", as it is the ").concat(foreignItem, " on ").concat(foreignKeyOnResource, " ").concat(id)) || this;
        _this.name = "ForeignKeyError";
        _this.stack = new global.Error('').stack;
        return _this;
    }
    return ForeignKeyError;
}(global.Error));
